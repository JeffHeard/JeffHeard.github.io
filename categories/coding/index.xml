<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jefferson Heard</title>
    <link>https://jeffersonheard.github.io/categories/coding/index.xml</link>
    <description>Recent content on Jefferson Heard</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="https://jeffersonheard.github.io/categories/coding/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Simplifying complex business logic with Python&#39;s Kanren</title>
      <link>https://jeffersonheard.github.io/2016/11/simplifying-complex-business-logic-with-pythons-kanren/</link>
      <pubDate>Sun, 27 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>https://jeffersonheard.github.io/2016/11/simplifying-complex-business-logic-with-pythons-kanren/</guid>
      <description>

&lt;p&gt;So-called &amp;ldquo;logic programming&amp;rdquo; has been a niche programming topic since Prolog
was introduced in the 80s. In my experience, most posts that cover logic
programming introduce the core concepts and stop there. The examples they
give are mostly toy problems. This post, then, will start with &amp;ldquo;what you can do
with logic programming in Python&amp;rdquo; and move toward the core concepts that way.&lt;/p&gt;

&lt;p&gt;If you&amp;rsquo;re looking for an explanation of &lt;strong&gt;unification&lt;/strong&gt; or a history of logic
programming, and why you should even write web-servers this way, there are
plenty of posts that will extoll the virtues of logic programming over other
methods. This is not that post. I&amp;rsquo;m aware of these things, but my goal in this
post is to help you take the part of your code that is &lt;em&gt;least&lt;/em&gt; maintainable as
written in a traditional Python style and make it cleaner, clearer, and less
prone to bugs using logic programming via the
&lt;a href=&#34;https://github.com/logpy/logpy&#34;&gt;Kanren&lt;/a&gt; library.&lt;/p&gt;

&lt;h2 id=&#34;not-what-it-is-but-what-is-it-for&#34;&gt;Not what it &lt;em&gt;is&lt;/em&gt;, but what is it &lt;em&gt;for&lt;/em&gt;?&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/logpy/logpy&#34;&gt;Kanren&lt;/a&gt; provides you a way to simplify the way
you specify and make your code respond to &amp;ldquo;business logic.&amp;rdquo; Business logic is an
ill defined term, but in my experience it consists of all those if-then-else
statements, nested cases, and rats&amp;rsquo; warrens of callbacks that evolve over time
in complex applications that focus either on complex data processing, or on
responding to users who are themselves experts at something.&lt;/p&gt;

&lt;p&gt;Kanren lets you express this logic in terms of rules and facts. I use Kanren to
do things like consistency checks in entered data, validity checks for records
that are POSTed to my APIs, and to perform complex filtering on users and
records that don&amp;rsquo;t translate well into database queries.&lt;/p&gt;

&lt;p&gt;Before we get started, you might want to do a quick:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ pip install kanren
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;for-if-not-then-else-what&#34;&gt;For if not then-else, what?&lt;/h2&gt;

&lt;p&gt;Although I will work to something more substantial, let&amp;rsquo;s start with a Hello
World. I start here because logic-programming is different enough to the way
most programmers think that a tiny, self-contained example will illustrate
some basic points.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; from kanren import run, eq, var
&amp;gt;&amp;gt;&amp;gt; x = var()
&amp;gt;&amp;gt;&amp;gt; run(1, x, eq(x, 5))
(5,)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We&amp;rsquo;ll skip the import and focus on the next statement. &lt;code&gt;x = var()&lt;/code&gt; declares a
variable, which &lt;code&gt;run&lt;/code&gt; will try to find one or more values for. &lt;code&gt;run&lt;/code&gt; is a
function that takes the following:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The number of results you want.&lt;/li&gt;
&lt;li&gt;The variables whose values you are interested in.&lt;/li&gt;
&lt;li&gt;The set of rules that defines the space of valid values for your variables.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The third bit is the most important, because it gives us a clue as to what
&lt;code&gt;eq(x, 5)&lt;/code&gt; means. It does &lt;em&gt;not&lt;/em&gt; mean &amp;ldquo;assign 5 to x&amp;rdquo;. Instead it &lt;em&gt;constrains&lt;/em&gt;
the result set so that it only includes results where &lt;code&gt;x&lt;/code&gt; is equal to 5. What&amp;rsquo;s
the difference?&lt;/p&gt;

&lt;p&gt;It will take a more complex example to truly show the difference, but for now
suffice to say that &lt;code&gt;eq(x, 5)&lt;/code&gt; works much more like the condition part of an
&lt;code&gt;if&lt;/code&gt; statement than a statement inside the if:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;for x, y, z in all_possibilities:
  if other_logic:
    # ...
    if x == 5:
      yield (x,)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In reality, Kanren is a highly efficient, optimizing evaluator of logical
expressions. There is (usually) no loop, but for illustration purposes, this is
what our example &amp;ldquo;means&amp;rdquo;. You can already see that we&amp;rsquo;ve taken a hairball of
potentially nested &lt;code&gt;ifs&lt;/code&gt; and &lt;code&gt;fors&lt;/code&gt; to a flat, sequential code structure in our
example.&lt;/p&gt;

&lt;h3 id=&#34;a-slightly-more-illustrative-example&#34;&gt;A (slightly) more illustrative example&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; set_a = {1, 2, 3}
&amp;gt;&amp;gt;&amp;gt; set_b = {2, 3, 4}
&amp;gt;&amp;gt;&amp;gt; run(2, x, (membero, x, set_a),  # x is a member of (1, 2, 3)
              (membero, x, set_b))  # x is a member of (2, 3, 4)
(2, 3)
&amp;gt;&amp;gt;&amp;gt; run(1, x, (membero, x, set_a),  # x is a member of (1, 2, 3)
              (membero, x, set_b))  # x is a member of (2, 3, 4)
(2,)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This example, taken from the Kanren &lt;code&gt;README&lt;/code&gt; is a little more illustrative. It
uses a new (to us) primitive, &lt;code&gt;membero&lt;/code&gt; to require that &lt;code&gt;x&lt;/code&gt; be a member of a
set. Note that the structure we&amp;rsquo;re checking membership of only has to be
iterable. It does not have to be a literal python set. Kanren operates on
primitive python types and their analogues, so if it swims like a duck and
quacks like a duck, then it&amp;rsquo;s a duck for Kanren purposes. There are no new data
structures to learn, conversions to make, or classes to unpack.&lt;/p&gt;

&lt;p&gt;I also introduced a different way to write the predicate. Instead of
&lt;code&gt;membero(x, set_a)&lt;/code&gt;, I wrote &lt;code&gt;(membero, x, set_a)&lt;/code&gt;. Although possibly a bit less
readable at first, nested structures are more readable this way, and I find that
after using the library in my own projects for a year or two, I like this style
better than the other.&lt;/p&gt;

&lt;p&gt;Now we see a new behavior of &lt;code&gt;run&lt;/code&gt;. It takes any number of clauses at the end
of the parameter list, and provides the logical and of all of them.  For our
purposes, we want two values of &lt;code&gt;x&lt;/code&gt; that satisfy all the predicates.&lt;/p&gt;

&lt;p&gt;Satisfying the first predicate, &lt;code&gt;(membero, x, set_a)&lt;/code&gt; are the values 1, 2, and 3,
since these are the members of &lt;code&gt;set_a&lt;/code&gt;. Satisfying the second predicate are the
values 2, 3, and 4, the members of &lt;code&gt;set_b&lt;/code&gt;. The only results shared between the
two are 2 and 3, so these are the results of our call to &lt;code&gt;run&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;In the first instance of run, we ask for two results. Each result is a single
value of x (as opposed to one set of members that match) and so we get a tuple
consisting of both matching numbers. If we ask for only one result, we get just
one number. This is important, because as I said earlier, Kanren works on so-
called duck typing (walks, swims, quacks, therefore serves the purposes of a
duck even if you happen to call it a swan). This means results can be a tuple of
numbers, dicts, tuples, lists, or custom types &amp;ndash; anything that can be compared
in the way the predicates do comparisons. This makes Kanren very pythonic and
very useful.&lt;/p&gt;

&lt;h2 id=&#34;making-it-more-relatable&#34;&gt;Making it more relatable&lt;/h2&gt;

&lt;p&gt;This is all fine, but it&amp;rsquo;s hardly something that by itself will make our logic
more readable. For that, we need to talk about relations and facts. Here is
an example adapted from the Kanren README:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; from kanren import Relation, facts
&amp;gt;&amp;gt;&amp;gt; parent = Relation()
&amp;gt;&amp;gt;&amp;gt; facts(parent, (&amp;quot;Homer&amp;quot;, &amp;quot;Bart&amp;quot;),
...               (&amp;quot;Marge&amp;quot;, &amp;quot;Bart&amp;quot;),
...               (&amp;quot;Homer&amp;quot;, &amp;quot;Lisa&amp;quot;),
...               (&amp;quot;Marge&amp;quot;, &amp;quot;Lisa&amp;quot;),
...               (&amp;quot;Homer&amp;quot;, &amp;quot;Maggie&amp;quot;),
...               (&amp;quot;Marge&amp;quot;, &amp;quot;Maggie&amp;quot;),
...               (&amp;quot;Abe&amp;quot;,  &amp;quot;Homer&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now let&amp;rsquo;s get one of the parents of Bart:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; run(1, x, (parent, x, &amp;quot;Bart&amp;quot;))
(&#39;Marge&#39;,)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Two of Homer&amp;rsquo;s children:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; run(2, x, parent(&amp;quot;Homer&amp;quot;, x))
(&#39;Bart&#39;, &#39;Lisa&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that there&amp;rsquo;s no order. The answer could have easily been &amp;ldquo;Homer&amp;rdquo; to the
first one or Lisa and Maggie to the second statement.&lt;/p&gt;

&lt;p&gt;Now, to show that relations are more than just fancy ways to construct tuples,
let&amp;rsquo;s figure out grandparents. We use an intermediate variable, &lt;code&gt;y&lt;/code&gt; to represent
the parent of Bart. Then &lt;code&gt;x&lt;/code&gt; is then the parent of the parent of bart.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; y = var()
&amp;gt;&amp;gt;&amp;gt; run(1, x, parent(x, y),
              parent(y, &#39;Bart&#39;))
(&#39;Abe&#39;,)

&amp;gt;&amp;gt;&amp;gt; run(1, (x, y), parent(x, y),
                   parent(y, &#39;Bart&#39;))
((&#39;Abe&#39;, &#39;Homer&#39;),)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This shows off Kanren&amp;rsquo;s advanced form of pattern matching known as &amp;ldquo;unification.&amp;rdquo;
Unification and backtracking are really not in the scope of this tutorial, but
you may find it helps to understand them in detail as you use Kanren in your own
programs. In that case, start with Kanren&amp;rsquo;s README and work from there.  For now
it is enough to consider that this works and its implications for writing
cleaner Python code.&lt;/p&gt;

&lt;p&gt;Note we can list more than one variable we are interested in the value of. This
will create a nested tuple of variable values in the same respective order as
they are listed in run.&lt;/p&gt;

&lt;p&gt;How might we have written this reasonably (if naïvely) in non-Kanren Python?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; parent_child = {
...   &amp;quot;Homer&amp;quot;: (&amp;quot;Bart&amp;quot;, &amp;quot;Lisa&amp;quot;, &amp;quot;Maggie&amp;quot;),
...   &amp;quot;Marge&amp;quot;: (&amp;quot;Bart&amp;quot;, &amp;quot;Lisa&amp;quot;, &amp;quot;Maggie&amp;quot;),
...   &amp;quot;Abe&amp;quot;: (&amp;quot;Homer&amp;quot;,)
... }

# getting homer&#39;s children is simple.
&amp;gt;&amp;gt;&amp;gt; parent_child[&#39;Homer&#39;][0:2]
(&amp;quot;Bart&amp;quot;, &amp;quot;Lisa&amp;quot;)

# figuring out Bart&#39;s parents looks completely different (or we have to store
# and maintain two dicts)
&amp;gt;&amp;gt;&amp;gt; barts_parents = []
&amp;gt;&amp;gt;&amp;gt; for parent in parent_child:
...   if &#39;Bart&#39; in parent_child[parent]:
...     barts_parents.append(parent)

# grandparents is even uglier, and requires we first compute parents.
&amp;gt;&amp;gt;&amp;gt; barts_grandparents = []
&amp;gt;&amp;gt;&amp;gt; for parent in barts_parents:  ## we computed this in the previous loop.
...   for grandparent in parent_child:
...     if parent in parent_child[grandparent]:
...       barts_grandparents.append(grandparent)  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The difference in legibility between the Kanren example and its admittedly
naïve Python equivalent should be obvious. In the Kanren example, we describe
relationships and assume they&amp;rsquo;re transitive. This not only serves to help us
work from either direction in the relationship with the same statement, it also
allows us to build these relationships up over time without having to maintain
multiple dictionaries or describe relationships in terms of iteration and if
statements.&lt;/p&gt;

&lt;p&gt;For simple logic that will never grow, it may be that the above is acceptable,
but it does tend to create code that people put big comments around warning the
interns off touching it.&lt;/p&gt;

&lt;h2 id=&#34;applying-it-to-a-real-world-example&#34;&gt;Applying it to a real-world example&lt;/h2&gt;

&lt;p&gt;Now for a more &amp;ldquo;real-world&amp;rdquo; test of Kanren.  Let&amp;rsquo;s create a consistency test for
a complex piece of JSON. First we&amp;rsquo;ll specify the JSON Schema for items in a
coffee shop order:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;type&amp;quot;: &amp;quot;object&amp;quot;,
  &amp;quot;required&amp;quot;: [&amp;quot;order_destination&amp;quot;],
  &amp;quot;properties&amp;quot;: {
    &amp;quot;order_destination&amp;quot;: {&amp;quot;type&amp;quot;: &amp;quot;string&amp;quot;, &amp;quot;enum&amp;quot;: [&amp;quot;espresso_machine&amp;quot;, &amp;quot;pastry_counter&amp;quot;]},
  },
  &amp;quot;definitions&amp;quot;: {
    &amp;quot;drink&amp;quot;: {
      &amp;quot;type&amp;quot;: &amp;quot;object&amp;quot;,
      &amp;quot;required&amp;quot;: [&amp;quot;size&amp;quot;, &amp;quot;order_type&amp;quot;],
      &amp;quot;properties&amp;quot;: {
        &amp;quot;size&amp;quot;: {&amp;quot;type&amp;quot;: &amp;quot;string&amp;quot;, &amp;quot;enum&amp;quot;: [&amp;quot;sm&amp;quot;, &amp;quot;md&amp;quot;, &amp;quot;lg&amp;quot;, &amp;quot;xl&amp;quot;]},
        &amp;quot;drink_type&amp;quot;: {&amp;quot;type&amp;quot;: &amp;quot;string&amp;quot;, &amp;quot;enum&amp;quot;: [&amp;quot;drip&amp;quot;, &amp;quot;espresso&amp;quot;, &amp;quot;latte&amp;quot;, &amp;quot;cappuccino&amp;quot;, &amp;quot;americano&amp;quot;]},
        &amp;quot;extras&amp;quot;: {&amp;quot;array&amp;quot;: { &amp;quot;$ref&amp;quot;: &amp;quot;#/definitions/extras&amp;quot; }},
      }
    },
    &amp;quot;pastry&amp;quot;: {
      &amp;quot;type&amp;quot;: &amp;quot;object&amp;quot;,
      &amp;quot;required&amp;quot;: [&amp;quot;quantity&amp;quot;, &amp;quot;item&amp;quot;],
      &amp;quot;properties&amp;quot;: {
        &amp;quot;item&amp;quot;: {&amp;quot;type&amp;quot;: &amp;quot;string&amp;quot;, &amp;quot;enum&amp;quot;: [&amp;quot;donut&amp;quot;, &amp;quot;sandwich&amp;quot;, &amp;quot;bagel&amp;quot;, &amp;quot;danish&amp;quot;]},
        &amp;quot;quantity&amp;quot;: {&amp;quot;type&amp;quot;: &amp;quot;integer&amp;quot;, &amp;quot;minValue&amp;quot;: 1, &amp;quot;maxValue&amp;quot;: 144},
        &amp;quot;heated&amp;quot;: {&amp;quot;type&amp;quot;: &amp;quot;boolean&amp;quot;, &amp;quot;default&amp;quot;: false}
      }
    },
    &amp;quot;extras&amp;quot;: {
      &amp;quot;type&amp;quot;: &amp;quot;object&amp;quot;,
      &amp;quot;properties&amp;quot;: {
        &amp;quot;flavoring&amp;quot;: {&amp;quot;type&amp;quot;: &amp;quot;string&amp;quot;},
        &amp;quot;milk_type&amp;quot;: {&amp;quot;type&amp;quot;: &amp;quot;string&amp;quot;, &amp;quot;enum&amp;quot;: [&amp;quot;soy&amp;quot;, &amp;quot;almond&amp;quot;, &amp;quot;skim&amp;quot;]}
      }
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;One thing that schema languages cannot often handle well are conditional
requirements. Conditional requirements occur when:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The presence of a value in one field limits the valid values in another field, or&lt;/li&gt;
&lt;li&gt;The presence of a value in one field requires the presence of another field.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In our case, the above schema defines an order at a coffee shop, but there are
valid JSON documents that nevertheless will not contain all the information
needed to complete an order.  We need some extra validation steps.  In particular,&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Depending on the order type, we need to ensure the presence of one of the
optional sections, &lt;code&gt;espresso_machine&lt;/code&gt; or &lt;code&gt;pastry_counter&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Shots of espresso can only be small or medium - no large or xl&lt;/li&gt;
&lt;li&gt;Cappuccinos can only be small, medium, or large. (we&amp;rsquo;re picky)&lt;/li&gt;
&lt;li&gt;Shots of espresso do not have milk in them (or they&amp;rsquo;d be something else)&lt;/li&gt;
&lt;li&gt;Americanos do not have milk.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We can create logic with Kanren that validates our JSON beyond what can simply
be done with basic schema validation.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from kanren import *

def validate_order(order):

  # validate conditional presence of section for order routing.
  must_contain_section = Relation()
  facts(must_contain_section, (&#39;espresso_machine&#39;, &#39;drink&#39;),
                              (&#39;pastry_counter&#39;, &#39;pastry&#39;))

  x = var()
  valid = run(1, x, must_contain_section(order[&#39;order_destination&#39;], x),
                    membero(x, set(order.keys())))  # See Note 1.

  if len(valid) == 0:
    raise ValidationError(&amp;quot;Required section not present&amp;quot;)
  elif order[&#39;order_destination&#39;] == &#39;espresso_machine&#39;:  # validate expresso orders
    drink = order[&#39;drink&#39;]

    # specify whether milk comes with each drink or not.
    # these could be specified once instead of every time the function is called.
    milk_comes_with = Relation(&#39;milk_comes_with&#39;)
    facts(milk_comes_with, (&#39;drip&#39;, True),
                           (&#39;latte&#39;, True),
                           (&#39;cappuccino&#39;, True),
                           (&#39;espresso&#39;, False),   # no milk for straight espresso
                           (&#39;americano&#39;, False))  # no milk in an americano

    drink_sizes = Relation(&#39;drink_size&#39;)

    # specify which sizes are valid for which drink.
    # these could be specified once instead of every time the function is called.
    facts(drink_sizes, *((&#39;drip&#39;, sz) for sz in [&#39;sm&#39;, &#39;md&#39;, &#39;lg&#39;, &#39;xl&#39;]),
                       *((&#39;latte&#39;, sz) for sz in [&#39;sm&#39;, &#39;md&#39;, &#39;lg&#39;, &#39;xl&#39;]),
                       *((&#39;americano&#39;, sz) for sz in [&#39;sm&#39;, &#39;md&#39;, &#39;lg&#39;, &#39;xl&#39;]),
                       *((&#39;cappuccino&#39;, sz) for sz in [&#39;sm&#39;, &#39;md&#39;, &#39;lg&#39;]),
                       *((&#39;espresso&#39;, sz) for sz in [&#39;sm&#39;, &#39;md&#39;]))

    # specify our drink type.
    drink_type = drink[&#39;drink_type&#39;]

    # check if if any of the extras specified a type of milk.
    specified_milk = False  
    for e in drink.get(&#39;extras&#39;, []):
      if &#39;milk_type&#39; in e:
        specified_milk = True
        break

    # these could run separately to come out with different errors.
    y = var()    
    valid = run(1, y,
      drink_sizes(drink_type, drink[&#39;size&#39;]),  # drink is a valid size
      # drink has a valid type of milk
      lany(  # any of the sub-clauses passing passes this.
        eq(specified_milk, False),  # drink has no milk
        # drink has milk and is of a valid drink type
        milk_comes_with(drink_type, specified_milk)))  

    if len(valid) == 0:
      raise ValidationError(&amp;quot;Drink size too large for drink type or milk included in non milk drink&amp;quot;)
  else:
    pass  # we may validate pastry orders next.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This results in the following passing validation:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;validate_order({&amp;quot;order_destination&amp;quot;: &amp;quot;espresso_machine&amp;quot;,
                &amp;quot;drink&amp;quot;: {&amp;quot;drink_type&amp;quot;: &amp;quot;espresso&amp;quot;,
                          &amp;quot;size&amp;quot;: &amp;quot;sm&amp;quot;}})

validate_order({&amp;quot;order_destination&amp;quot;: &amp;quot;espresso_machine&amp;quot;,
                &amp;quot;drink&amp;quot;: {&amp;quot;drink_type&amp;quot;: &amp;quot;latte&amp;quot;,
                          &amp;quot;size&amp;quot;: &amp;quot;lg&amp;quot;,
                          &amp;quot;extras&amp;quot;: [{&amp;quot;milk_type&amp;quot;: &amp;quot;soy&amp;quot;}]}})        

validate_order({&amp;quot;order_destination&amp;quot;: &amp;quot;espresso_machine&amp;quot;,
                &amp;quot;drink&amp;quot;: {&amp;quot;drink_type&amp;quot;: &amp;quot;latte&amp;quot;,
                          &amp;quot;size&amp;quot;: &amp;quot;lg&amp;quot;}})            
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And the following will not pass validation:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# no large espressos at this coffee shop. You&#39;ve had enough!
validate_order({&amp;quot;order_destination&amp;quot;: &amp;quot;espresso_machine&amp;quot;,
                &amp;quot;drink&amp;quot;: {&amp;quot;drink_type&amp;quot;: &amp;quot;espresso&amp;quot;,
                          &amp;quot;size&amp;quot;: &amp;quot;lg&amp;quot;}})

# added a custom milk type to a non-milk drink
validate_order({&amp;quot;order_destination&amp;quot;: &amp;quot;espresso_machine&amp;quot;,
      &amp;quot;drink&amp;quot;: {&amp;quot;drink_type&amp;quot;: &amp;quot;espresso&amp;quot;,
                &amp;quot;size&amp;quot;: &amp;quot;sm&amp;quot;,
                &amp;quot;extras&amp;quot;: [{&amp;quot;milk_type&amp;quot;: &amp;quot;soy&amp;quot;}]}})


# required section not present
validate_order({&amp;quot;order_destination&amp;quot;: &amp;quot;espresso_machine&amp;quot;})
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;notes&#34;&gt;Notes&lt;/h5&gt;

&lt;ol&gt;
&lt;li&gt;Here we make a set out of the properties of our &amp;ldquo;order&amp;rdquo; document. The full
test makes sure that both clauses are true. So &lt;code&gt;x&lt;/code&gt; must be the required section
for our order type, and it must be present as a named property in our document.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Thus this is valid:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&amp;quot;order_destination&amp;quot;: &amp;quot;espresso_machine&amp;quot;, &amp;quot;drink&amp;quot;: {...}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And this is not:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{&amp;quot;order_destination&amp;quot;: &amp;quot;espresso_machine&amp;quot;, &amp;quot;pastry&amp;quot;: {...}}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;further-thoughts&#34;&gt;Further thoughts&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Reusability is your friend.&lt;/strong&gt; So far we&amp;rsquo;ve only seen interactive usage of Kanren.
What about embedding it in software? It&amp;rsquo;s probably obvious that you can wrap the
&lt;code&gt;run&lt;/code&gt; call in a function and work with the results, but it turns out you can
wrap up and make relations and predicates reusable as well. &lt;a href=&#34;https://github.com/logpy/logpy/blob/master/examples/corleone.py&#34;&gt;See the Godfather example in Kanren&amp;rsquo;s source&lt;/a&gt;.
You can even make &lt;a href=&#34;https://github.com/logpy/logpy/blob/master/examples/user_classes.py&#34;&gt;custom types usable&lt;/a&gt;
within Kanren&amp;rsquo;s logical relations.&lt;/p&gt;

&lt;p&gt;There are things missing from the complex example. It&amp;rsquo;s possible to create much
more complex validations using Kanren and all its primitives. There are also
other ways to express logic more succinctly than we did in the example, however
for an introduction, I think these can be too dense to be readily digested.
Best to experiment with your code and see what works.&lt;/p&gt;

&lt;p&gt;For further reading, I suggest starting with the &lt;a href=&#34;http://minikanren.org/&#34;&gt;specification of miniKanren&lt;/a&gt;,
which was originally written in Scheme, and then &lt;a href=&#34;https://github.com/logpy/logpy&#34;&gt;the Python Kanren repo&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Creating new fields and widgets for Mozilla&#39;s react-jsonschema-form</title>
      <link>https://jeffersonheard.github.io/2016/11/creating-new-fields-and-widgets-for-mozillas-react-jsonschema-form/</link>
      <pubDate>Mon, 21 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>https://jeffersonheard.github.io/2016/11/creating-new-fields-and-widgets-for-mozillas-react-jsonschema-form/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://github.com/mozilla-services/react-jsonschema-form&#34;&gt;Mozilla&amp;rsquo;s react-jsonschema-form&lt;/a&gt;
is my favorite tool to build forms. Its forms play well with REST APIs, they
look good, and  they are easy to work with and extend. In the most basic usage,
you take a &lt;a href=&#34;http://json-schema.org/&#34;&gt;JSON-Schema&lt;/a&gt; and simply pass it to the
component like so:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import React, { PropTypes } from &#39;react&#39;;
import Form from &#39;react-jsonschema-form&#39;;

const mySchema = { ... }
const changeHandler = ({formData}) =&amp;gt; { ... }; // formData is JSON that conforms to your schema.

const MyForm = (props) =&amp;gt; (&amp;lt;Form schema={mySchema} onChange={changeHandler} /&amp;gt;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Which yields a form like the one on the right:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://camo.githubusercontent.com/a491e6355cc814b195bc0060c93b023dfe8a72ac/687474703a2f2f692e696d6775722e636f6d2f626d5133486c4f2e706e67&#34; /&gt;&lt;/p&gt;

&lt;p&gt;You can define either &lt;code&gt;onChange&lt;/code&gt; or &lt;code&gt;onSubmit&lt;/code&gt; properties as functions that
accept an object with a &lt;code&gt;formData&lt;/code&gt; attribute. The &lt;code&gt;formData&lt;/code&gt; will be an object
that conforms to your schema.&lt;/p&gt;

&lt;p&gt;Customizing the form is as simple as defining a uiSchema. This post, after
introducing the component, will cover customization using fields and widgets,
and when each is appropriate.&lt;/p&gt;

&lt;h2 id=&#34;a-couple-of-notes-about-json-schema&#34;&gt;A couple of notes about JSON Schema&lt;/h2&gt;

&lt;p&gt;I have read a number of arguments online for and against
&lt;a href=&#34;http://json-schema.org/&#34;&gt;JSON-Schema&lt;/a&gt; in principle.  My answer to all of these
arguments is &amp;ldquo;JSON Schema works for my purposes, and for many others&amp;rsquo; purposes.
It&amp;rsquo;s not perfect. It doesn&amp;rsquo;t really have to be.&amp;rdquo; My experience with internet
holy wars tells me to ignore them and adapt the best tools for my purposes that
seem like they&amp;rsquo;ll also be useful in future projects. JSON Schema is one such
technology.&lt;/p&gt;

&lt;p&gt;If you want a totally extensible, general case schema language, JSON Schema
probably isn&amp;rsquo;t your best language. I however want to use it to declaratively
define documents to be stored in a NoSQL database (&lt;a href=&#34;https://rethinkdb.com&#34;&gt;RethinkDB&lt;/a&gt;)
and to interact with those documents in mobile apps and on web forms. I want to
do minimal processing and work on the client and server side to make the simple
things work, as there&amp;rsquo;s only so much time in the day, and most of that time is
expensive.&lt;/p&gt;

&lt;p&gt;If you&amp;rsquo;re like me, then JSON Schema is a good choice. You should continue
on reading.&lt;/p&gt;

&lt;p&gt;For me, the best part of JSON Schema is that it&amp;rsquo;s very lean. There&amp;rsquo;s not a lot
to learn, and it&amp;rsquo;s not at all restrictive. Any JSON fragment can contain
schema, and any schema fragment can contain arbitrary properties that validation
implementations will ignore, which makes it easy to give hints about the data
to your application by embedding metadata in the schema. I use this extensively
when generating forms that rely on custom components.&lt;/p&gt;

&lt;h2 id=&#34;react-jsonschema-form&#34;&gt;react-jsonschema-form&lt;/h2&gt;

&lt;p&gt;The great thing about &lt;a href=&#34;https://github.com/mozilla-services/react-jsonschema-form&#34;&gt;react-jsonschema-form&lt;/a&gt;
beyond its simplicity and customizability is that it is &lt;em&gt;predictable&lt;/em&gt;. The
components that are generated by React have the same structure as your schema,
exactly. Digging into the tree with react development tools gives you a clear
picture of what data exists at any level and in any place in the form. Every
field component has a &lt;code&gt;formData&lt;/code&gt; attribute that contains JSON in compliance
with the schema fragment it represents. Every fragment is individually represented
and properly nested. Every widget has a &lt;code&gt;value&lt;/code&gt; attribute that contains a
string, number, boolean, or null - any basic JSON type.&lt;/p&gt;

&lt;p&gt;It may seem like I am harping on this feature, but I have found remarkably few
form builders that follow this level of rigor in the data they generate. I find
that the meat-and-potatoes of user data entry is almost debugger-free, and I can
therefore spend my time figuring out the hard stuff. When I do open the
debugger, I know exactly where to look to find what I&amp;rsquo;m after, because I know
a priori how the tree is laid out.&lt;/p&gt;

&lt;p&gt;In short, there is no &lt;em&gt;magic&lt;/em&gt; in the way &lt;code&gt;react-jsonschema-form&lt;/code&gt; works. Since I
come from languages like Python and Lisp, I like this design a lot.&lt;/p&gt;

&lt;h3 id=&#34;non-obvious-behaviors&#34;&gt;Non-obvious Behaviors&lt;/h3&gt;

&lt;p&gt;The documentation for &lt;code&gt;react-jsonschema-form&lt;/code&gt; is really quite good; there are a
few things that you will run into that may not be obvious on first use.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Fields that are left empty by the user will be omitted from the JSON &lt;em&gt;unless&lt;/em&gt;
a default is defined in the schema. If during data entry a user clears
a field, that field will be omitted from the JSON. &lt;em&gt;&lt;strong&gt;This is the cause of a
common coder error&lt;/strong&gt;&lt;/em&gt;. If you use an API method
that updates records in place, rather than replaces them, this can cause
a simple error where the record in the backend store doesn&amp;rsquo;t reflect a user
deleting data within the record.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Booleans that are required need to have a custom widget defined in the
&lt;code&gt;uiSchema&lt;/code&gt; (radio works fine), otherwise they come up as checkboxes, whose
&lt;code&gt;formData&lt;/code&gt; is always either &lt;code&gt;true&lt;/code&gt; or omitted (and therefore invalid).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Arrays defined in the schema will &lt;em&gt;always&lt;/em&gt; create headings in the form, even
if there are no items in the array. That&amp;rsquo;s fine, but it can be confusing
to read the form when there are arrays nested in objects. You may need custom
CSS or to define a post-processing function to make the form clearer to the
user.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Arrays marked as &lt;code&gt;readOnly&lt;/code&gt; will create buttons, although they&amp;rsquo;re disabled.&lt;br /&gt;
Use the schema and a function to traverse the DOM and remove the buttons you
don&amp;rsquo;t want.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The difference between &amp;ldquo;field&amp;rdquo; and &amp;ldquo;widget&amp;rdquo; isn&amp;rsquo;t &lt;em&gt;actually&lt;/em&gt; subtle, but it
might seem like it is at first.  Generally, if your type is a &lt;em&gt;collection&lt;/em&gt;,
be that an object or an array, it is a &amp;ldquo;field&amp;rdquo;. If it is a single simple value,
then it is a &lt;em&gt;widget&lt;/em&gt;. Read below for more examples.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;customization-patterns&#34;&gt;Customization patterns&lt;/h3&gt;

&lt;p&gt;The documentation for &lt;code&gt;react-jsonschema-form&lt;/code&gt; is all in one page.  It is
complete, but it can be a bit intimidating if you haven&amp;rsquo;t used the project
before.&lt;/p&gt;

&lt;p&gt;I put metadata in my schema that says a bit more about the data than is
conveyed directly.  This metadata might specify that a string is generally  a
barcode, or refers to a file on the web or to an image url or to a &amp;ldquo;foreign
key.&amp;rdquo; I also specify in metadata sometimes how &amp;ldquo;large&amp;rdquo; a choice-set is likely
to be. This helps me intelligently determine what kind of selection widget to
use, and  whether or not to load all  choices from the server or to use an
autocomplete function to speed up  user interaction and provide a better
experience.&lt;/p&gt;

&lt;p&gt;Example schema fragments. Note, there is no built-in way to handle these within
JSON-Schema form, but you can use a processing function to read a schema and
create a custom &lt;code&gt;uiSchema&lt;/code&gt; that uses custom widgets based on this metadata:&lt;/p&gt;

&lt;p&gt;Let the application know that a string is a barcode.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{ &amp;quot;type&amp;quot;: &amp;quot;string&amp;quot;, &amp;quot;represents&amp;quot;: &amp;quot;barcode&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let the application know that an object is a GeoJSON point.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{ &amp;quot;type&amp;quot;: &amp;quot;object&amp;quot;, &amp;quot;represents&amp;quot;: &amp;quot;geometry&amp;quot;, &amp;quot;geometryType&amp;quot;: &amp;quot;point&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;JSON-Schema has a &lt;code&gt;format&lt;/code&gt; keyword. That format only works for strings, however,
and may also have special meaning to certain validators. I find it best to use
a different keyword to reflect semantics of anything outside of a simple
date-time. After all, there&amp;rsquo;s no &lt;em&gt;formatting&lt;/em&gt; difference between a string that
represents a file and one that represents an image.&lt;/p&gt;

&lt;p&gt;Here is an example schema I have used with custom JSONSchema form widgets:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{ &amp;quot;type&amp;quot;: &amp;quot;object&amp;quot;,
  &amp;quot;title&amp;quot;: &amp;quot;Representation&amp;quot;,
  &amp;quot;description&amp;quot;: &amp;quot;Metadata embedded within a schema that is used by the form builder or applications&amp;quot;,
  &amp;quot;properties&amp;quot;: {
    &amp;quot;represents&amp;quot;: {&amp;quot;type&amp;quot;: &amp;quot;string&amp;quot;, &amp;quot;enum&amp;quot;: [
      &amp;quot;image&amp;quot;,
      &amp;quot;file&amp;quot;,
      &amp;quot;barcode&amp;quot;,
      &amp;quot;geom&amp;quot;,
      &amp;quot;foreignKey&amp;quot;
    ]},
    &amp;quot;fkSize&amp;quot;: {&amp;quot;type&amp;quot;: &amp;quot;string&amp;quot;, &amp;quot;enum&amp;quot;: [&amp;quot;sm&amp;quot;, &amp;quot;med&amp;quot;, &amp;quot;large&amp;quot;]},
    &amp;quot;fkUrl&amp;quot;: {&amp;quot;type&amp;quot;: &amp;quot;string&amp;quot;, &amp;quot;format&amp;quot;: &amp;quot;url&amp;quot;},
    &amp;quot;uploadPath&amp;quot;: {&amp;quot;type&amp;quot;: &amp;quot;string&amp;quot;},
    &amp;quot;uploadHost&amp;quot;: {&amp;quot;type&amp;quot;: &amp;quot;string&amp;quot;},
    &amp;quot;geomType&amp;quot;: {&amp;quot;type&amp;quot;: &amp;quot;string&amp;quot;, &amp;quot;enum&amp;quot;: [&amp;quot;point&amp;quot;, &amp;quot;line&amp;quot;, &amp;quot;polygon&amp;quot;, &amp;quot;multipoint&amp;quot;, &amp;quot;multiline&amp;quot;, &amp;quot;multipolygon&amp;quot;]},
    &amp;quot;geomProj&amp;quot;: {&amp;quot;type&amp;quot;: &amp;quot;string&amp;quot;, &amp;quot;pattern&amp;quot;: &amp;quot;(epsg|EPSG):[0-9]+&amp;quot;, &amp;quot;default&amp;quot;: &amp;quot;EPSG:4326&amp;quot;}
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is meant as a starting point, not a final list. In the next section, I will
cover how to generate a widget that handles input and display for images&lt;/p&gt;

&lt;h2 id=&#34;building-a-custom-widget-for-images&#34;&gt;Building a custom widget for images&lt;/h2&gt;

&lt;p&gt;In this section, we&amp;rsquo;ll build a widget that handles an image upload. A custom
widget is simply a React component. For the sake of the tutorial, we are also
using &lt;a href=&#34;https://react-bootstrap.github.io/&#34;&gt;react-bootstrap&lt;/a&gt;. Most React
developers seem to be familiar with &lt;code&gt;react-boostrap&lt;/code&gt;, and it makes the code much
more readable in my opinion.&lt;/p&gt;

&lt;p&gt;To fully understand the rest of the code in this tutorial, you will need to
familiarize yourself with the following concepts above and beyond JSON Schema:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://react-bootstrap.github.io/&#34;&gt;react-bootstrap&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developers.google.com/web/fundamentals/getting-started/primers/promises&#34;&gt;Promises&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&#34;&gt;Fetch&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A key assumption I make is that we know how to upload the image the user selects
a priori. In particular,&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Our upload endpoint accepts a further path component that segments images uploaded
from different collections.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Our upload endpoint returns the URL where the image can be reached as a bare string.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;We are using a token-based authentication / authorization method that requires
the Authorization HTTP header. This is common in schemes like
&lt;a href=&#34;https://jwt.io/&#34;&gt;JSON Web Tokens.&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If you wanted to make this more customizable, you would want to rewrite
&lt;code&gt;changeHandler&lt;/code&gt; to pull the actual upload portion from the &lt;code&gt;ui:options&lt;/code&gt; section
in the &lt;code&gt;uiSchema&lt;/code&gt; that describes this component. It will be passed to this
component in the &lt;code&gt;options&lt;/code&gt; property. This exercise is left for the reader, or
you can simply gut the changeHandler and rewrite it to serve your purposes.&lt;/p&gt;

&lt;p&gt;Next is the annotated code for the image component. It is mostly complete, but
error handling is left to the reader as an exercise.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import React, { PropTypes } from &#39;react&#39;;
import { FormGroup, ControlLabel, FormControl, ProgressBar,
  Image, HelpBlock, ListGroup, ListGroupItem } from &#39;react-bootstrap&#39;;

export const PictureSelectionWidget = React.createClass({

  // define transient state that aids in displaying the component,
  // e.g. whether upload is in progress.
  getInitialState() {
    return {
      uploadInProgress: false  
    };
  },

  // this is passed to the input component, in this case a &#39;file&#39; control.
  // It actually uploads the file and sets the formData to the result.
  changeHandler(event) {
    const {
      onChange,  // passed in from the Form. Always call this in a handler.
      options  // ui:options in uiSchema for this widget
    } = this.props;

    // These come up ui:options in the uiSchema for this widget.
    const { uploadPath, uploadHost } = options;
    const f = event.target.files[0]; // grab the File object from the InputControl.

    // check to make sure we have an image file. A complete implementation would
    // signal an error if the user passed in something that wasn&#39;t.
    if (f.type.match(&#39;image.*&#39;)) {
      let headers = new Headers();

      // the user&#39;s authorization token if it is present.
      // Assume it&#39;s kept in localStorage.
      const authToken = localStorage.auth_token;  
      if(authToken) {
        headers.append(&#39;Authorization&#39;, `Bearer ${authToken}`);
      }

      // This is the &amp;quot;body&amp;quot; of the fetch. We will append the file.
      let formData = new FormData();
      formData.append(&#39;file&#39;, f);

      // This forms the fetch request and options.
      const requestOptions = {
        mode: &#39;cors&#39;,  // handle cross-origin requests gracefully,
        method: &#39;POST&#39;,  // make a POST request
        body: formData,  // append the file
        headers  // add the user&#39;s auth token to the request.
      };

      // fetch is an asynchronous API. This is the last statement that executes
      // fully before the handler returns control to its caller. We indicate
      // here that an upload has started.
      this.setState({uploadInProgress: true});

      // make the asynchronous request. For programmers more familiar with
      // callback syntax the &amp;quot;success&amp;quot; callback is the &amp;quot;then&amp;quot; and the error is
      // the &amp;quot;catch&amp;quot;.
      fetch(`${uploadHost}${uploadPath}`, requestOptions).then((rsp) =&amp;gt; {

        // still have to make sure that the code was a 2xx. &amp;quot;errors&amp;quot; are quirky
        // and need a full read of Fetch docs.
        if(rsp.ok) {

          rsp.text().then(downloadUrl =&amp;gt; {

            // call the react-jsonschema-form onChange method, which updates the
            // formData in the parents and all the way up the tree.
            // THIS MUST HAPPEN IN EVERY CUSTOM COMPONENT!
            onChange(downloadUrl);  

          });
        } else {

          // woefully inadequate error handling.
          console.error(rsp);
        }
        // resolve the upload as complete in the component state.
        this.setState({uploadInProgress: false});  
      }).catch(err =&amp;gt; {
        console.error(err);  // did i mention you should write error handling?
        // resolve the upload as complete in the component state.
        this.setState({uploadInProgress: false});
      });  
    }
  },

  render() {
    const {
      schema,  // ONLY the fragment that this widget represents.
               // { &amp;quot;type&amp;quot;: &amp;quot;string&amp;quot;, &amp;quot;represents&amp;quot;: &amp;quot;image&amp;quot;, ... }
      placeholder,  // from react-jsonschema-form uiSchema
      value,        // from react-jsonschema-form, the actual value that goes in the JSON.
      readonly,     // from react-jsonschema-form uiSchema &amp;quot;ui:readonly&amp;quot;
      options       // from react-jsonschema-form uiSchema &amp;quot;ui:options&amp;quot;
    } = this.props;

    // set in changeHandler when an upload starts and when it completes.
    const { uploadInProgress } = this.state;
    const imageUrl = formData || value;

    // render the image if the &amp;quot;value&amp;quot; is not null.
    let img = (&amp;lt;div&amp;gt;No Image&amp;lt;/div&amp;gt;);
    if(imageUrl) {
      img = (&amp;lt;Image src={imageUrl} thumbnail /&amp;gt;);
    }

    // An empty array will serve in place of a &amp;quot;null&amp;quot; for React&#39;s rendering engine.
    // Render a progress bar if we are waiting on the file upload to finish.
    const progressBar = uploadInProgress ? (&amp;lt;ProgressBar now={80} animated /&amp;gt;) : [];

    // A readonly file control is meaningless, and we have to render the image
    // separately anyway, so just omit the file control if we are readonly.
    const inputControl = readonly ? [] : (&amp;lt;FormControl type=&#39;file&#39; onChange={this.changeHandler} /&amp;gt;);

    return (&amp;lt;FormGroup&amp;gt;
      {img}
      {progressBar}
      {inputControl}
    &amp;lt;/FormGroup&amp;gt;);
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When filled out, the widget looks like this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://jeffersonheard.github.io/img/post/imagewidget-screenshot.jpg&#34; height=&#34;480&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;building-a-custom-field-for-geometry&#34;&gt;Building a custom field for geometry&lt;/h2&gt;

&lt;p&gt;Geometry is not a &amp;ldquo;simple&amp;rdquo; type in JSON.  GeoJSON is a JSON format that describes
a physical location and comes in the form of an object rather than a piece of
text. When dealing with data that is a composite, either an array or an object,
you define a &amp;ldquo;field&amp;rdquo; instead of a &amp;ldquo;widget&amp;rdquo;&lt;/p&gt;

&lt;p&gt;In this section, we&amp;rsquo;ll create such a field. Our GeoPosition field will be very
simplistic.  If you were developing for mobile, you might make it a simple
button that ties to &lt;code&gt;navigator.getCurrentPosition&lt;/code&gt;. Or you might make it a map
via &lt;a href=&#34;https://leafletjs.com&#34;&gt;Leaflet&lt;/a&gt; and allow someone to construct a geometry
by hand.  Here we will make it two text boxes with a link to display on a map.&lt;/p&gt;

&lt;p&gt;Like a widget, a field is just a React component.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;export const GeoPositionField = React.createClass({
  onChange(name) {
    return (event) =&amp;gt; {
      let data = _.has(this.props.formData, &#39;coordinates&#39;)
        ? this.props.formData
        : {type: &#39;Point&#39;, coordinates: [0, 0]};

      const [x, y] = data.coordinates;
      let number = event.target.value ? _.toNumber(event.target.value) : 0;
      number = _.isNaN(number) ? 0 : number;

      if(name === &#39;lon&#39;) {
        data = {coordinates: [number, y]};
      } else { // if(name === &#39;lat&#39;) {
        data = {coordinates: [x, number]};
      }

      // just like in the widget definition.
      this.props.onChange(this.state);  
    };
  },

  render() {
    let lon = 0;
    let lat = 0;
    let geoURL = [];

    // if our data is non-null
    if(_.has(this.props, &#39;formData.coordinates&#39;) &amp;amp;&amp;amp; _.isArray(this.props.formData.coordinates)) {
      // set lon and lat. used later as well.
      [lon, lat] = this.props.formData.coordinates;

      // build a URL to open Google maps in a new window.
      if(_.has(window, &#39;device&#39;) &amp;amp;&amp;amp; window.device.platform === &#39;Android&#39;) {
        geoURL = (&amp;lt;a href={`geo:${lat},${lon}`}&amp;gt;Open in Map&amp;lt;/a&amp;gt;);
      } else {
        geoURL = (&amp;lt;a target=&#39;_blank&#39; href={`https://maps.google.com/?ll=${lat},${lon}`}&amp;gt;Open in Map&amp;lt;/a&amp;gt;);
      }
    }

    // Note that here we set the labels up. Since we are defining the field
    // ourselves, we have to to labeling and help ourselves.
    return (
      &amp;lt;div className=&amp;quot;geo&amp;quot;&amp;gt;
        &amp;lt;label&amp;gt;Location&amp;lt;/label&amp;gt;
        &amp;lt;div className=&amp;quot;well&amp;quot;&amp;gt;
        &amp;lt;div className=&amp;quot;row&amp;quot;&amp;gt;
          &amp;lt;div className=&amp;quot;col-xs-6&amp;quot;&amp;gt;
            &amp;lt;label&amp;gt;Longitude&amp;lt;/label&amp;gt;
            &amp;lt;input className=&amp;quot;form-control&amp;quot; type=&amp;quot;number&amp;quot; value={lon} step=&amp;quot;0.00001&amp;quot;
              onChange={this.onChange(&amp;quot;lon&amp;quot;)} /&amp;gt;
          &amp;lt;/div&amp;gt;
          &amp;lt;div className=&amp;quot;col-xs-6&amp;quot;&amp;gt;
            &amp;lt;label&amp;gt;Latitude&amp;lt;/label&amp;gt;
            &amp;lt;input className=&amp;quot;form-control&amp;quot; type=&amp;quot;number&amp;quot; value={lat} step=&amp;quot;0.00001&amp;quot;
              onChange={this.onChange(&amp;quot;lat&amp;quot;)} /&amp;gt;
          &amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;
        &amp;lt;div className=&amp;quot;row&amp;quot;&amp;gt;
          &amp;lt;div className=&amp;quot;col-xs-12&amp;quot;&amp;gt;
            {geoURL}
          &amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;
      &amp;lt;/div&amp;gt;
    );
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The main difference between a Field and a Widget, then, is to what it attaches
in the schema. The other notable difference is that labeling and help have to
be handled in the field definition, where they do not in the widget definition.&lt;/p&gt;

&lt;h2 id=&#34;using-the-widget-and-fields-in-your-ui&#34;&gt;Using the widget and fields in your ui&lt;/h2&gt;

&lt;h3 id=&#34;explicit-declaration&#34;&gt;Explicit declaration&lt;/h3&gt;

&lt;p&gt;You can explicitly use the new widget and field in your UI by registering it and
creating a &lt;code&gt;uiSchema&lt;/code&gt; that contains it. The other common way is to use a
function that processes schemata and searches for metadata attributes, like our
&amp;ldquo;represents&amp;rdquo; schema from the beginning of this post.  Let&amp;rsquo;s start with explicit,
though:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const schema = {
  type: &amp;quot;object&amp;quot;,
  properties: {
    image: {
      type: &amp;quot;object&amp;quot;,
      properties: {
        imageUrl: {
          type: &amp;quot;string&amp;quot;,
          represents: &amp;quot;image&amp;quot;,
          uploadHost: &amp;quot;http://localhost:8080&amp;quot;,
          uploadPath: &amp;quot;/upload&amp;quot;
        },
        location: {
          type: &amp;quot;object&amp;quot;,
          represents: &amp;quot;geom&amp;quot;,
          geomType: &amp;quot;Point&amp;quot;,
          geomProj: &amp;quot;EPSG:4326&amp;quot;
        }
      }
    },

  }
};

const uiSchema = {
  image: {
    imageUrl: {
      &amp;quot;ui:widget&amp;quot;: PictureSelectionWidget,
      &amp;quot;ui:options&amp;quot;: {
        uploadHost: &amp;quot;http://localhost:8080&amp;quot;,
        uploadPath: &amp;quot;/upload&amp;quot;
      }
    }
    location: {
      &amp;quot;ui:field&amp;quot;: GeoPositionField,
      &amp;quot;ui:options&amp;quot;: {
        geomType: &amp;quot;Point&amp;quot;,
        geomProj: &amp;quot;EPSG:4326&amp;quot;,
      }
    }
  }
}

render((
  &amp;lt;Form schema={schema}
        uiSchema={uiSchema} /&amp;gt;
), document.getElementById(&amp;quot;app&amp;quot;));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we have copied the &lt;code&gt;uploadHost&lt;/code&gt; and &lt;code&gt;uploadPath&lt;/code&gt; and geometry metadata
properties by hand into the options. In an automatic ui function, one would
process the schema and copy those programmatically. By the way, the Form does
allow you to specify a field and widget registry. In that case, your uiSchema
can refer to the widget by string name instead of having to pass in the class.
If your ui schemas need to be loaded from URLs or JSON strings, this will be
helpful.&lt;/p&gt;

&lt;h3 id=&#34;programmatic-declaration&#34;&gt;Programmatic declaration&lt;/h3&gt;

&lt;p&gt;Now let&amp;rsquo;s see what a schema processing function might look like.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import _ from &#39;lodash&#39;;  // use lodash.js to simplify our code.  see https://lodash.com

// this function searches properties for
function autoProp(uiSchema, prop, name, isArray) {
  switch(prop.represents) {
    case &amp;quot;image&amp;quot;:
      uiSchema[name] = {
        &amp;quot;ui:widget&amp;quot;: PictureSelectionField,
        &amp;quot;ui:options&amp;quot;: {
          uploadHost: prop.uploadHost,
          uploadPath: prop.uploadPath
        }
      };
      break;    
      // add other cases for your user defined fields here.
    default:
      break;
  }
}

// recursively explore schemas and fill their properties in.  Does not handle
// external references, only references to the &amp;quot;definitions&amp;quot; section in the
// schema.
export function autoUiSchema(schema) {
 let uiSchema = {};
 if(_.has(schema, &#39;properties&#39;)) {
   _.forEach(schema.properties, (prop, name) =&amp;gt;

     // recursively iterate through properties with nested objects.
     if(prop.type === &#39;object&#39;) {
       if(_.has(prop, &#39;represents&#39;) &amp;amp;&amp;amp; prop.represents === &amp;quot;geom&amp;quot;) {  
         uiSchema[name] = {
           &#39;ui:field&#39;: GeoJSONField,
           &amp;quot;ui:options&amp;quot;: {geomType: prop.geomType, geomProj: props.geomProj}};
       } else {
         uiSchema[name] = autoUiSchema(prop);
       }
     } else if(prop.type === &#39;array&#39;) {  // handle arrays by processing &amp;quot;items&amp;quot;
      if(_.has(prop.items, &amp;quot;$ref&amp;quot;)) {  
        // splice the schema from the $ref in and process as if it was inline.
        let subschema = _.assign({},
          {definitions: schema.definitions},
          schema.definitions[prop.items.$ref.split(&#39;/&#39;)[2]]
        );
        uiSchema[name] = {items: autoUiSchema(subschema)};
      } else if(prop.items.type === &#39;object&#39;) {
        // recurse into objects
        uiSchema[name] = {items: autoUiSchema(prop.items)};
      } else {
        // otherwise it&#39;s a simple property
        autoProp(uiSchema, prop.items, name, true);
      }
    } else if(_.has(prop, &#39;$ref&#39;)) {
      // handle an internal reference. the same way we handled it in array.
      let subschema = _.assign({},
        {definitions: schema.definitions},
        schema.definitions[prop.$ref.split(&#39;/&#39;)[2]]);

      // now recurse into the spliced schema
      uiSchema[name] = autoUiSchema(subschema);
    } else {
      // if we make it here, our property is a simple property. Check and see if
      // its metadata is something we can process.
      autoProp(uiSchema, prop, name);
    }
   });
 }
 return uiSchema;
}

// in real life this would be a component of some kind.
render((
  &amp;lt;Form schema={schema}
        uiSchema={autoUiSchema(schema)} /&amp;gt;
), document.getElementById(&amp;quot;app&amp;quot;));

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These functions really just require reading the annotations. However, as an
overview, the &lt;code&gt;autoProp&lt;/code&gt; function is called at a &amp;ldquo;leaf&amp;rdquo; node of the schema,
and always by &lt;code&gt;autoUiSchema&lt;/code&gt;.  The developer then calls &lt;code&gt;autoUiSchema&lt;/code&gt; with the
schema itself and gets a proper ui schema back.&lt;/p&gt;

&lt;p&gt;Note that this is often not quite enough to define a uiSchema. You may well want
to customize the schema further after doing everything that can be automated.&lt;/p&gt;

&lt;p&gt;These functions are general enough, but not to the point of being &amp;ldquo;general use&amp;rdquo;.
You will have to adapt them to your own purposes. In particular, responsive
applications where certain data can be input by sensors on a mobile device, but
must be entered by hand on a laptop browser may require different functions or
post processing the ui schema to handle every case well.&lt;/p&gt;

&lt;p&gt;Please feel free to ask me any questions or submit corrections to my code here.
I have adapted this code from my own projects, and although it works in those
projects, deletion and cleanup in the post may have introduced errors
unintentionally.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>An Intro to Sondra: Part 4</title>
      <link>https://jeffersonheard.github.io/2016/11/an-intro-to-sondra-part-4/</link>
      <pubDate>Sun, 20 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>https://jeffersonheard.github.io/2016/11/an-intro-to-sondra-part-4/</guid>
      <description>

&lt;h2 id=&#34;adding-data-in-python&#34;&gt;Adding data in Python&lt;/h2&gt;

&lt;p&gt;The simplest way to add data is through Python.  Data can be added from Python
even to private collections, and methods can be called without authentication.
This means that code that calls methods and creates objects, perhaps as part of
other methods, should do sufficient permission checking to cover both itself and
the potential mutations to data caused by the methods and collections it calls.&lt;/p&gt;

&lt;p&gt;Assuming our suite is in an object called &lt;code&gt;api&lt;/code&gt;, this is how we add data:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; api[&#39;todo-app&#39;][&#39;items&#39;].create({
...     &amp;quot;title&amp;quot;: &amp;quot;Remember the milk.&amp;quot;,
...     &amp;quot;created&amp;quot;: datetime.utcnow()
... })
&amp;lt;examples.todo.Item object at 0x10f611160&amp;gt;

&amp;gt;&amp;gt;&amp;gt; next(iter(api[&#39;todo-app&#39;][&#39;items&#39;]))
&#39;642478b1-03bb-45e2-9f6d-e90e90d1b7cf&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The second line demonstrates that Sondra indeed follows the dict pattern closely.  Getting an
iterator over the collection returns a generator that yields keys. This is done via a single
cursor, and is thus very efficient.  You can also use &lt;code&gt;.keys()&lt;/code&gt; and &lt;code&gt;.values()&lt;/code&gt; and even &lt;code&gt;.items()&lt;/code&gt;
as you expect to, yielding primary keys, Document objects, and pairs as they are supposed to.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; items = api[&#39;todo-app&#39;][&#39;items&#39;]
&amp;gt;&amp;gt;&amp;gt; len(items)
1
&amp;gt;&amp;gt;&amp;gt; items.keys()
KeysView(&amp;lt;examples.todo.Items object at 0x110d40a90&amp;gt;)
&amp;gt;&amp;gt;&amp;gt; items.values()
ValuesView(&amp;lt;examples.todo.Items object at 0x110d40a90&amp;gt;)
&amp;gt;&amp;gt;&amp;gt; items.items()
ItemsView(&amp;lt;examples.todo.Items object at 0x110d40a90&amp;gt;)
&amp;gt;&amp;gt;&amp;gt; &#39;642478b1-03bb-45e2-9f6d-e90e90d1b7cf&#39; in items
True
&amp;gt;&amp;gt;&amp;gt; items[&#39;642478b1-03bb-45e2-9f6d-e90e90d1b7cf&#39;] in items
True
&amp;gt;&amp;gt;&amp;gt; first_item = items[&#39;642478b1-03bb-45e2-9f6d-e90e90d1b7cf&#39;]
&amp;gt;&amp;gt;&amp;gt; first_item
&amp;lt;examples.todo.Item object at 0x10f611160&amp;gt;
&amp;gt;&amp;gt;&amp;gt; first_item.obj
OrderedDict([(&#39;complete&#39;, False), (&#39;created&#39;, &#39;2016-10-13T18:45:08.255000+00:00&#39;),
    (&#39;title&#39;, &#39;Remember the milk.&#39;), (&#39;id&#39;, &#39;642478b1-03bb-45e2-9f6d-e90e90d1b7cf&#39;)])
&amp;gt;&amp;gt;&amp;gt; first_item == &#39;642478b1-03bb-45e2-9f6d-e90e90d1b7cf&#39;
True
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The last line deserves some explanation. An item is always equal to its primary key, even though we
are really comparing strings and objects. This may be counterintuitive, but it makes for fewer
queries internally and is thus more efficient than the obvious implementation.&lt;/p&gt;

&lt;p&gt;Another thing to note is that Sondra takes care to map data to its proper datatype whenever possible.
There&amp;rsquo;s a little &amp;ldquo;magic&amp;rdquo; in this, but it is explained deeper in the documentation.  For example,
let&amp;rsquo;s look at our &amp;ldquo;created&amp;rdquo; attribute:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; first_item[&#39;created&#39;]

datetime.datetime(2016, 10, 20, 16, 21, 54, 546629)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sondra uses &amp;ldquo;value handlers&amp;rdquo;, found in the &lt;code&gt;sondra.documents.valuehandlers&lt;/code&gt; section of the sondra
code to translate between Python datatypes, JSON datatypes, and RethinkDB datatypes. To determine
the datatype, you need look no further than the schema itself. The following shows what schema
attributes  Sondra uses to treat values specially:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;{... &amp;quot;format&amp;quot;: &amp;quot;date-time&amp;quot;}&lt;/code&gt; - Handled as a Python datetime, JSON string, RethinkDB date.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{... &amp;quot;geo&amp;quot;: true}&lt;/code&gt; - Handled as a Python dict-like object (a geometry object if Shapely is installed,
otherwise it will fall back to a dict), JSON object (as GeoJSON geometry), RethinkDB geometry
type.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Sondra is compatible with the base datetime library and with &lt;a href=&#34;http://crsmithdev.com/arrow/&#34;&gt;arrow&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;adding-and-accessing-data-over-http-s&#34;&gt;Adding and accessing data over HTTP(S)&lt;/h2&gt;

&lt;p&gt;For this section, we&amp;rsquo;re going to assume you will get around to authentication. A basic
authentication and authorization app exists in the Sondra codebase, but you will probably want to
use other, more well-tested frameworks to handle authentication and authorization of web requests in
Flask. This is just fine and well supported. For now, we will assume that a POST will work without
authorization, so you can follow the tutorial without reading extra material.&lt;/p&gt;

&lt;p&gt;Sondra is fairly standard when it comes to REST metaphors, but for reference, here is how HTTP
commands map to operations on the API:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;GET&lt;/code&gt; - &lt;strong&gt;Retrieve&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;Retrieve a document,&lt;/li&gt;
&lt;li&gt;list of documents, or&lt;/li&gt;
&lt;li&gt;make a simple method call&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;POST&lt;/code&gt; - &lt;strong&gt;Add or Replace&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;Add items to a collection.&lt;/li&gt;
&lt;li&gt;Replace an existing document.&lt;/li&gt;
&lt;li&gt;Make a more complex method call.&lt;/li&gt;
&lt;li&gt;As a special case, you can use JSON to map any of the other commands to a POST. More details in
the source code or the detailed documentation to come.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PUT&lt;/code&gt; - &lt;strong&gt;Replace&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;Replace items in a collection.&lt;/li&gt;
&lt;li&gt;Replace an existing document.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PATCH&lt;/code&gt; - &lt;strong&gt;Update in Place&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;Make updates to items in a collection.&lt;/li&gt;
&lt;li&gt;Make updates to a single document. (Merges dicts to create updates)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DELETE&lt;/code&gt; - &lt;strong&gt;Delete&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;Delete items from a collection. Delete a single document.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We&amp;rsquo;ll use the Python requests library. By default, Flask exposes itself over port 5000 on localhost,
so that&amp;rsquo;s the assumption we will make. We will also make the assumption that you are &lt;em&gt;not&lt;/em&gt; changing
the default api base path, which is simply &lt;code&gt;api&lt;/code&gt;.  First, let&amp;rsquo;s get the record we&amp;rsquo;ve already
created:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; rsp = requests.get(&#39;http://localhost:5000/api/todo-app/items&#39;)
&amp;gt;&amp;gt;&amp;gt; rsp.json

[{&#39;id&#39;: &#39;642478b1-03bb-45e2-9f6d-e90e90d1b7cf&#39;, &#39;complete&#39;: False,
  &#39;created&#39;: &#39;2016-10-13T18:45:08.255000+00:00&#39;, &#39;title&#39;, &#39;Remember the milk.&#39;}]

&amp;gt;&amp;gt;&amp;gt; requests.get(&#39;http://localhost:5000/api/todo-app/items/642478b1-03bb-45e2-9f6d-e90e90d1b7cf&#39;).json()

{&#39;id&#39;: &#39;642478b1-03bb-45e2-9f6d-e90e90d1b7cf&#39;, &#39;complete&#39;: False,
 &#39;created&#39;: &#39;2016-10-13T18:45:08.255000+00:00&#39;, &#39;title&#39;, &#39;Remember the milk.&#39;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now how about adding data?  Let&amp;rsquo;s actually use an example in Javascript, since that&amp;rsquo;s how an API
like this will most commonly be used.  Here we&amp;rsquo;re using the &amp;ldquo;fetch&amp;rdquo; API, but you could do the same
with a standard XMLHttpRequest.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Javascript&#34;&gt;fetch(&#39;http://localhost:5000/api/todo-app/items&#39;, {
  method: &#39;POST&#39;,
  mode: &#39;cors&#39;,
  body: JSON.stringify({
    title: &#39;Remember the cheese&#39;,
    complete: false,
    created: new Date()
  })
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;replace-the-document-on-the-server&#34;&gt;Replace the document on the server&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-Javascript&#34;&gt;fetch(&#39;http://localhost:5000/api/todo-app/items/642478b1-03bb-45e2-9f6d-e90e90d1b7cf&#39;, {
  method: &#39;POST&#39;,
  mode: &#39;cors&#39;,
  body: JSON.stringify({
    title: &#39;Remember the milk&#39;,
    complete: true,
    created: new Date()
  })
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will actually replace the document with the given ID. If you omit any properties from the
document, they will be omitted in the replacement, since this effectively destroys the old copy and
puts a new one in its place on the database.  What if we just want to say that the item has been
completed?  After all, we don&amp;rsquo;t want to update the &amp;ldquo;created&amp;rdquo; field, since now the data is wrong.&lt;/p&gt;

&lt;h3 id=&#34;update-properties-on-the-document-on-the-server&#34;&gt;Update properties on the document on the server.&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-Javascript&#34;&gt;fetch(&#39;http://localhost:5000/api/todo-app/items/642478b1-03bb-45e2-9f6d-e90e90d1b7cf&#39;, {
  method: &#39;PATCH&#39;,
  mode: &#39;cors&#39;,
  body: JSON.stringify({complete: true})
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;PATCH&lt;/code&gt; method only updates the properties that you give to the request, leaving the others
unchanged.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>An Intro to Sondra: Part 3</title>
      <link>https://jeffersonheard.github.io/2016/11/an-intro-to-sondra-part-3/</link>
      <pubDate>Fri, 18 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>https://jeffersonheard.github.io/2016/11/an-intro-to-sondra-part-3/</guid>
      <description>

&lt;h2 id=&#34;accessing-schemas&#34;&gt;Accessing Schemas&lt;/h2&gt;

&lt;p&gt;If you missed them, see my previous tutorials covering
&lt;a href=&#34;tutorial-1&#34;&gt;first steps into Sondra&lt;/a&gt; and &lt;a href=&#34;tutorial-2&#34;&gt;exposing your API to the web&lt;/a&gt;.
This tutorial will cover accessing the JSON-Schema that underlies the API. All Sondra
APIs are based on JSON-Schema, and dictate not only what the documents must look like
coming in and out of Sondra, but also how to access method calls and query datasets.&lt;/p&gt;

&lt;p&gt;First, let&amp;rsquo;s start out with a simple call to the schema endpoint. A schema endpoint can
be accessed from every level of the API including suite, application, collection, and
document (although document schemas are typically the same as collection schemas).&lt;/p&gt;

&lt;h3 id=&#34;schema-endpoints&#34;&gt;Schema Endpoints&lt;/h3&gt;

&lt;p&gt;Let&amp;rsquo;s look at this in a browser. Run the module in a terminal window, open your favorite browser, and
surf to &lt;a href=&#34;http://localhost:5000/api;schema&#34;&gt;http://localhost:5000/api;schema&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
    &amp;quot;title&amp;quot;: &amp;quot;Sondra-Based API&amp;quot;,
    &amp;quot;definitions&amp;quot;: {
        &amp;quot;filterOps&amp;quot;: {
            &amp;quot;enum&amp;quot;: [
                &amp;quot;with_fields&amp;quot;,
                &amp;quot;count&amp;quot;,
                &amp;quot;max&amp;quot;,
                &amp;quot;min&amp;quot;,
                &amp;quot;avg&amp;quot;,
                &amp;quot;sample&amp;quot;,
                &amp;quot;sum&amp;quot;,
                &amp;quot;distinct&amp;quot;,
                &amp;quot;contains&amp;quot;,
                &amp;quot;pluck&amp;quot;,
                &amp;quot;without&amp;quot;,
                &amp;quot;has_fields&amp;quot;,
                &amp;quot;order_by&amp;quot;,
                &amp;quot;between&amp;quot;
            ]
        },
        &amp;quot;timedelta&amp;quot;: {
            &amp;quot;type&amp;quot;: &amp;quot;object&amp;quot;,
            &amp;quot;required&amp;quot;: [
                &amp;quot;start&amp;quot;,
                &amp;quot;end&amp;quot;
            ],
            &amp;quot;properties&amp;quot;: {
                &amp;quot;hours&amp;quot;: {
                    &amp;quot;type&amp;quot;: &amp;quot;integer&amp;quot;
                },
                &amp;quot;days&amp;quot;: {
                    &amp;quot;type&amp;quot;: &amp;quot;integer&amp;quot;
                },
                &amp;quot;seconds&amp;quot;: {
                    &amp;quot;type&amp;quot;: &amp;quot;number&amp;quot;
                },
                &amp;quot;minutes&amp;quot;: {
                    &amp;quot;type&amp;quot;: &amp;quot;integer&amp;quot;
                }
            }
        },
        &amp;quot;spatialOps&amp;quot;: {
            &amp;quot;enum&amp;quot;: [
                &amp;quot;distance&amp;quot;,
                &amp;quot;get_intersecting&amp;quot;,
                &amp;quot;get_nearest&amp;quot;
            ]
        }
    },
    &amp;quot;type&amp;quot;: &amp;quot;object&amp;quot;,
    &amp;quot;id&amp;quot;: &amp;quot;http://localhost:5000/api;schema&amp;quot;,
    &amp;quot;applications&amp;quot;: {
        &amp;quot;todo-app&amp;quot;: &amp;quot;http://localhost:5000/api/todo-app&amp;quot;
    },
    &amp;quot;description&amp;quot;: &amp;quot;*No description provided.*&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s pretty neat! A few basic datatypes exist in the definitions, mainly to define how filtering
and query-sets work. We&amp;rsquo;ll get into those later.  For now, we&amp;rsquo;ll focus on what we just created.  The
suite schema doesn&amp;rsquo;t show us the data-type that we defined, but it does show a list of applications
and their endpoints in &lt;code&gt;.applications&lt;/code&gt;. Note that our application is no longer CamelCase, but has
been turned into kabob-case. This is the default, but it can be configured otherwise. All levels
of the API are turned from CamelCase or underscore_separation into kabob-case by default, for
consistency, and because this is more typical of url patterns than the other case types.&lt;/p&gt;

&lt;h3 id=&#34;application-schema&#34;&gt;Application Schema&lt;/h3&gt;

&lt;p&gt;Let&amp;rsquo;s check out the schema to todo-app.  We&amp;rsquo;ll use the url
in the schema followed by &lt;code&gt;;schema&lt;/code&gt;. Sondra is very regular about the way it treats urls. Formatting
and pragmas are handled using url parameters. This is different than changing the endpoint for the
file-type, which is typical of many other frameworks. The reason for this is that often, there are
multiple ways to render data and keep it in the same file type.  For instance, the &lt;code&gt;schema&lt;/code&gt; and
&lt;code&gt;json&lt;/code&gt; types allow you to control the ordering and whether data is pretty-printed with lines and
indentations. Other formats allow other parameters as we&amp;rsquo;ll see later on.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;id&amp;quot;: &amp;quot;http://localhost:5000/api/todo-app;schema&amp;quot;,
  &amp;quot;definitions&amp;quot;: {},
  &amp;quot;collections&amp;quot;: {
    &amp;quot;items&amp;quot;: &amp;quot;http://localhost:5000/api/todo-app/items&amp;quot;
  },
  &amp;quot;type&amp;quot;: &amp;quot;object&amp;quot;,
  &amp;quot;title&amp;quot;: &amp;quot;Todo App&amp;quot;,
  &amp;quot;methods&amp;quot;: {},
  &amp;quot;description&amp;quot;: &amp;quot;*No description provided.*&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is the application schema.  Once again, this is rather succinct. There&amp;rsquo;s not a lot of
information in here, but if there were methods defined at the application level we would see them
show up here.  One can also add application level schema fragment definitions in the class and
they would show up here.&lt;/p&gt;

&lt;h3 id=&#34;collection-schema&#34;&gt;Collection Schema&lt;/h3&gt;

&lt;p&gt;Let&amp;rsquo;s move on to the items themselves. Go to &lt;a href=&#34;http://localhost:5000/api/todo-app/items;schema;indent=2&#34;&gt;http://localhost:5000/api/todo-app/items;schema;indent=2&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;type&amp;quot;: &amp;quot;object&amp;quot;,
  &amp;quot;properties&amp;quot;: {
    &amp;quot;title&amp;quot;: {
      &amp;quot;type&amp;quot;: &amp;quot;string&amp;quot;,
      &amp;quot;title&amp;quot;: &amp;quot;Title&amp;quot;,
      &amp;quot;description&amp;quot;: &amp;quot;The title of the item&amp;quot;
    },
    &amp;quot;complete&amp;quot;: {
      &amp;quot;type&amp;quot;: &amp;quot;boolean&amp;quot;,
      &amp;quot;title&amp;quot;: &amp;quot;Complete&amp;quot;,
      &amp;quot;default&amp;quot;: false
    },
    &amp;quot;created&amp;quot;: {
      &amp;quot;type&amp;quot;: &amp;quot;string&amp;quot;,
      &amp;quot;title&amp;quot;: &amp;quot;Created&amp;quot;,
      &amp;quot;format&amp;quot;: &amp;quot;date-time&amp;quot;
    },
    &amp;quot;id&amp;quot;: {
      &amp;quot;type&amp;quot;: &amp;quot;string&amp;quot;,
      &amp;quot;title&amp;quot;: &amp;quot;ID&amp;quot;,
      &amp;quot;description&amp;quot;: &amp;quot;The primary key.&amp;quot;
    }
  },
  &amp;quot;methods&amp;quot;: {
    &amp;quot;count&amp;quot;: {
      &amp;quot;id&amp;quot;: &amp;quot;count&amp;quot;,
      &amp;quot;oneOf&amp;quot;: [
        {
          &amp;quot;$ref&amp;quot;: &amp;quot;#/definitions/method_request&amp;quot;
        },
        {
          &amp;quot;$ref&amp;quot;: &amp;quot;#/definitions/method_response&amp;quot;
        }
      ],
      &amp;quot;title&amp;quot;: &amp;quot;Object Count&amp;quot;,
      &amp;quot;definitions&amp;quot;: {
        &amp;quot;method_request&amp;quot;: {
          &amp;quot;type&amp;quot;: &amp;quot;null&amp;quot;,
          &amp;quot;title&amp;quot;: &amp;quot;Object Count&amp;quot;,
          &amp;quot;side_effects&amp;quot;: false,
          &amp;quot;description&amp;quot;: &amp;quot;The number of objects in the collection.&amp;quot;
        },
        &amp;quot;method_response&amp;quot;: {
          &amp;quot;type&amp;quot;: &amp;quot;object&amp;quot;,
          &amp;quot;title&amp;quot;: &amp;quot;Object Count&amp;quot;,
          &amp;quot;properties&amp;quot;: {
            &amp;quot;\_&amp;quot;: {
              &amp;quot;type&amp;quot;: &amp;quot;number&amp;quot;
            }
          },
          &amp;quot;description&amp;quot;: &amp;quot;The number of objects in the collection.&amp;quot;
        }
      },
      &amp;quot;description&amp;quot;: &amp;quot;The number of objects in the collection.&amp;quot;
    },
    &amp;quot;key-list&amp;quot;: {
      &amp;quot;id&amp;quot;: &amp;quot;key-list&amp;quot;,
      &amp;quot;oneOf&amp;quot;: [
        {
          &amp;quot;$ref&amp;quot;: &amp;quot;#/definitions/method_request&amp;quot;
        },
        {
          &amp;quot;$ref&amp;quot;: &amp;quot;#/definitions/method_response&amp;quot;
        }
      ],
      &amp;quot;title&amp;quot;: &amp;quot;Keys&amp;quot;,
      &amp;quot;definitions&amp;quot;: {
        &amp;quot;method_request&amp;quot;: {
          &amp;quot;type&amp;quot;: &amp;quot;null&amp;quot;,
          &amp;quot;title&amp;quot;: &amp;quot;Keys&amp;quot;,
          &amp;quot;side_effects&amp;quot;: false,
          &amp;quot;description&amp;quot;: &amp;quot;*No description provided*&amp;quot;
        },
        &amp;quot;method_response&amp;quot;: {
          &amp;quot;type&amp;quot;: &amp;quot;array&amp;quot;,
          &amp;quot;title&amp;quot;: &amp;quot;Keys&amp;quot;,
          &amp;quot;items&amp;quot;: {
            &amp;quot;type&amp;quot;: &amp;quot;string&amp;quot;
          },
          &amp;quot;description&amp;quot;: &amp;quot;*No description provided*&amp;quot;
        }
      },
      &amp;quot;description&amp;quot;: &amp;quot;*No description provided*&amp;quot;
    },
    &amp;quot;autocomplete&amp;quot;: {
      &amp;quot;id&amp;quot;: &amp;quot;autocomplete&amp;quot;,
      &amp;quot;oneOf&amp;quot;: [
        {
          &amp;quot;$ref&amp;quot;: &amp;quot;#/definitions/method_request&amp;quot;
        },
        {
          &amp;quot;$ref&amp;quot;: &amp;quot;#/definitions/method_response&amp;quot;
        }
      ],
      &amp;quot;title&amp;quot;: &amp;quot;Autocomplete&amp;quot;,
      &amp;quot;definitions&amp;quot;: {
        &amp;quot;method_request&amp;quot;: {
          &amp;quot;type&amp;quot;: &amp;quot;object&amp;quot;,
          &amp;quot;title&amp;quot;: &amp;quot;Autocomplete&amp;quot;,
          &amp;quot;properties&amp;quot;: {
            &amp;quot;partial&amp;quot;: {
              &amp;quot;type&amp;quot;: &amp;quot;string&amp;quot;,
              &amp;quot;title&amp;quot;: &amp;quot;Partial&amp;quot;,
              &amp;quot;description&amp;quot;: &amp;quot;A regular expression to match on any and all of the autocomplete fields.&amp;quot;
            }
          },
          &amp;quot;side_effects&amp;quot;: false,
          &amp;quot;description&amp;quot;: &amp;quot;Search results based on a partial input as a regex&amp;quot;
        },
        &amp;quot;method_response&amp;quot;: {
          &amp;quot;type&amp;quot;: &amp;quot;array&amp;quot;,
          &amp;quot;title&amp;quot;: &amp;quot;Autocomplete&amp;quot;,
          &amp;quot;items&amp;quot;: {
            &amp;quot;type&amp;quot;: &amp;quot;object&amp;quot;,
            &amp;quot;properties&amp;quot;: {
              &amp;quot;k&amp;quot;: {
                &amp;quot;type&amp;quot;: &amp;quot;string&amp;quot;
              },
              &amp;quot;v&amp;quot;: {
                &amp;quot;type&amp;quot;: &amp;quot;string&amp;quot;
              }
            }
          },
          &amp;quot;description&amp;quot;: &amp;quot;Search results based on a partial input as a regex&amp;quot;
        }
      },
      &amp;quot;description&amp;quot;: &amp;quot;Search results based on a partial input as a regex&amp;quot;
    },
    &amp;quot;key-map&amp;quot;: {
      &amp;quot;id&amp;quot;: &amp;quot;key-map&amp;quot;,
      &amp;quot;oneOf&amp;quot;: [
        {
          &amp;quot;$ref&amp;quot;: &amp;quot;#/definitions/method_request&amp;quot;
        },
        {
          &amp;quot;$ref&amp;quot;: &amp;quot;#/definitions/method_response&amp;quot;
        }
      ],
      &amp;quot;title&amp;quot;: &amp;quot;Key Map&amp;quot;,
      &amp;quot;definitions&amp;quot;: {
        &amp;quot;method_request&amp;quot;: {
          &amp;quot;type&amp;quot;: &amp;quot;null&amp;quot;,
          &amp;quot;title&amp;quot;: &amp;quot;Key Map&amp;quot;,
          &amp;quot;side_effects&amp;quot;: false,
          &amp;quot;description&amp;quot;: &amp;quot;*No description provided*&amp;quot;
        },
        &amp;quot;method_response&amp;quot;: {
          &amp;quot;type&amp;quot;: &amp;quot;object&amp;quot;,
          &amp;quot;title&amp;quot;: &amp;quot;Key Map&amp;quot;,
          &amp;quot;description&amp;quot;: &amp;quot;*No description provided*&amp;quot;
        }
      },
      &amp;quot;description&amp;quot;: &amp;quot;*No description provided*&amp;quot;
    }
  },
  &amp;quot;definitions&amp;quot;: {
    &amp;quot;filterOps&amp;quot;: {
      &amp;quot;enum&amp;quot;: [
        &amp;quot;with_fields&amp;quot;,
        &amp;quot;count&amp;quot;,
        &amp;quot;max&amp;quot;,
        &amp;quot;min&amp;quot;,
        &amp;quot;avg&amp;quot;,
        &amp;quot;sample&amp;quot;,
        &amp;quot;sum&amp;quot;,
        &amp;quot;distinct&amp;quot;,
        &amp;quot;contains&amp;quot;,
        &amp;quot;pluck&amp;quot;,
        &amp;quot;without&amp;quot;,
        &amp;quot;has_fields&amp;quot;,
        &amp;quot;order_by&amp;quot;,
        &amp;quot;between&amp;quot;
      ]
    },
    &amp;quot;timedelta&amp;quot;: {
      &amp;quot;type&amp;quot;: &amp;quot;object&amp;quot;,
      &amp;quot;required&amp;quot;: [
        &amp;quot;start&amp;quot;,
        &amp;quot;end&amp;quot;
      ],
      &amp;quot;properties&amp;quot;: {
        &amp;quot;hours&amp;quot;: {
          &amp;quot;type&amp;quot;: &amp;quot;integer&amp;quot;
        },
        &amp;quot;days&amp;quot;: {
          &amp;quot;type&amp;quot;: &amp;quot;integer&amp;quot;
        },
        &amp;quot;seconds&amp;quot;: {
          &amp;quot;type&amp;quot;: &amp;quot;number&amp;quot;
        },
        &amp;quot;minutes&amp;quot;: {
          &amp;quot;type&amp;quot;: &amp;quot;integer&amp;quot;
        }
      }
    },
    &amp;quot;spatialOps&amp;quot;: {
      &amp;quot;enum&amp;quot;: [
        &amp;quot;distance&amp;quot;,
        &amp;quot;get_intersecting&amp;quot;,
        &amp;quot;get_nearest&amp;quot;
      ]
    }
  },
  &amp;quot;template&amp;quot;: &amp;quot;{id}&amp;quot;,
  &amp;quot;documentMethods&amp;quot;: {
    &amp;quot;rel&amp;quot;: {
      &amp;quot;id&amp;quot;: &amp;quot;\*rel&amp;quot;,
      &amp;quot;oneOf&amp;quot;: [
        {
          &amp;quot;$ref&amp;quot;: &amp;quot;#/definitions/method_request&amp;quot;
        },
        {
          &amp;quot;$ref&amp;quot;: &amp;quot;#/definitions/method_response&amp;quot;
        }
      ],
      &amp;quot;title&amp;quot;: &amp;quot;Related Documents&amp;quot;,
      &amp;quot;definitions&amp;quot;: {
        &amp;quot;method_request&amp;quot;: {
          &amp;quot;type&amp;quot;: &amp;quot;object&amp;quot;,
          &amp;quot;properties&amp;quot;: {
            &amp;quot;app&amp;quot;: {
              &amp;quot;type&amp;quot;: &amp;quot;string&amp;quot;,
              &amp;quot;title&amp;quot;: &amp;quot;App&amp;quot;,
              &amp;quot;description&amp;quot;: &amp;quot;The slug of the application ``coll`` is in.&amp;quot;
            },
            &amp;quot;coll&amp;quot;: {
              &amp;quot;type&amp;quot;: &amp;quot;string&amp;quot;,
              &amp;quot;title&amp;quot;: &amp;quot;Coll&amp;quot;,
              &amp;quot;description&amp;quot;: &amp;quot;The slug of the collection to search for documents in.&amp;quot;
            },
            &amp;quot;related_key&amp;quot;: {
              &amp;quot;type&amp;quot;: &amp;quot;string&amp;quot;,
              &amp;quot;title&amp;quot;: &amp;quot;Related Key&amp;quot;,
              &amp;quot;description&amp;quot;: &amp;quot;The name of the key to search for this document in.If none, defaults to the first matching foreign key element.&amp;quot;
            }
          },
          &amp;quot;required&amp;quot;: [
            &amp;quot;app&amp;quot;,
            &amp;quot;coll&amp;quot;
          ],
          &amp;quot;title&amp;quot;: &amp;quot;Related Documents&amp;quot;,
          &amp;quot;description&amp;quot;: &amp;quot;Reverse relation.  Get a query set of all documents in a collection that have foreign keys that point to this document.&amp;quot;,
          &amp;quot;side_effects&amp;quot;: false
        },
        &amp;quot;method_response&amp;quot;: {
          &amp;quot;type&amp;quot;: &amp;quot;object&amp;quot;,
          &amp;quot;properties&amp;quot;: {},
          &amp;quot;title&amp;quot;: &amp;quot;Related Documents&amp;quot;,
          &amp;quot;description&amp;quot;: &amp;quot;Reverse relation.  Get a query set of all documents in a collection that have foreign keys that point to this document.&amp;quot;
        }
      },
      &amp;quot;description&amp;quot;: &amp;quot;...&amp;quot;
    }
  },
  &amp;quot;primary_key&amp;quot;: &amp;quot;id&amp;quot;,
  &amp;quot;description&amp;quot;: &amp;quot;No Description Provided.&amp;quot;,
  &amp;quot;title&amp;quot;: &amp;quot;Item&amp;quot;,
  &amp;quot;id&amp;quot;: &amp;quot;http://localhost:5000/api/todo-app/items;schema&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s a lot more information!. This may look very dense, but it contains all the methods and inherits
all the schema from the application and suite objects as well. This allows buggy JSON schema parsers
to find references without having to fetch other documents in the course of resolving references.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s remove the methods for a moment and see what we have:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;template&amp;quot;: &amp;quot;{id}&amp;quot;,
  &amp;quot;primary_key&amp;quot;: &amp;quot;id&amp;quot;,
  &amp;quot;description&amp;quot;: &amp;quot;No Description Provided.&amp;quot;,
  &amp;quot;title&amp;quot;: &amp;quot;Item&amp;quot;,
  &amp;quot;id&amp;quot;: &amp;quot;http://localhost:5000/api/todo-app/items;schema&amp;quot;,
  &amp;quot;type&amp;quot;: &amp;quot;object&amp;quot;,
  &amp;quot;required&amp;quot;: [&amp;quot;title&amp;quot;],
  &amp;quot;properties&amp;quot;: {
    &amp;quot;title&amp;quot;: {
      &amp;quot;type&amp;quot;: &amp;quot;string&amp;quot;,
      &amp;quot;title&amp;quot;: &amp;quot;Title&amp;quot;,
      &amp;quot;description&amp;quot;: &amp;quot;The title of the item&amp;quot;
    },
    &amp;quot;complete&amp;quot;: {
      &amp;quot;type&amp;quot;: &amp;quot;boolean&amp;quot;,
      &amp;quot;title&amp;quot;: &amp;quot;Complete&amp;quot;,
      &amp;quot;default&amp;quot;: false
    },
    &amp;quot;created&amp;quot;: {
      &amp;quot;type&amp;quot;: &amp;quot;string&amp;quot;,
      &amp;quot;title&amp;quot;: &amp;quot;Created&amp;quot;,
      &amp;quot;format&amp;quot;: &amp;quot;date-time&amp;quot;
    },
    &amp;quot;id&amp;quot;: {
      &amp;quot;type&amp;quot;: &amp;quot;string&amp;quot;,
      &amp;quot;title&amp;quot;: &amp;quot;ID&amp;quot;,
      &amp;quot;description&amp;quot;: &amp;quot;The primary key.&amp;quot;
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;JSON-Schema tells us what we&amp;rsquo;re looking at here, but just to be clear, all Sondra has done is
translated the code into JSON for the client. There are a few properties that are extra to JSON
Schema, such as &lt;code&gt;template&lt;/code&gt; and &lt;code&gt;primary_key&lt;/code&gt;. These are defined by Sondra. Template describes how
one would create a visual representation for a record. Primary key lets you know what data field to
use to address documents as endpoints. If you had a document with id &lt;code&gt;00ab-00ac-00ad-00ae&lt;/code&gt; then you
would access it via the API as &lt;code&gt;http://localhost:5000/api/todo-app/items/00ab-00ac-00ad-00ae&lt;/code&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>An Intro to Sondra: Part 2</title>
      <link>https://jeffersonheard.github.io/2016/11/an-intro-to-sondra-part-2/</link>
      <pubDate>Tue, 15 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>https://jeffersonheard.github.io/2016/11/an-intro-to-sondra-part-2/</guid>
      <description>&lt;p&gt;Part 2 of our tutorials on Sondra build on our sample application from part 1
and covers exposing the API on the web. Basically we will add one more module,
which creates a Flask app. The app I show below does very little more
than the basic Flask app. It adds compression, because that&amp;rsquo;s pretty standard
these days and supported by almost all browsers.  It&amp;rsquo;s also a good idea with
APIs where responses can get very long.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from flask import Flask
from flask.ext.compress import Compress
from sondra.flask import api_tree, init

# Create the Flask instance and the suite.
app = Flask(__name__)
Compress(app)  # This is not necessary, but I find it generally helpful.
app.debug = True
app.suite = TodoSuite()
init(app)

# Register all the applications.
TodoApp(app.suite)

# Create all databases and tables.
app.suite.validate()  # remember this call?
app.suite.ensure_database_objects()  # and this one?

# Attach the API to the /api/ endpoint.
app.register_blueprint(api_tree, url_prefix=&#39;/api&#39;)

if __name__ == &#39;__main__&#39;:
    app.run()

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It&amp;rsquo;s probably pretty obvious what&amp;rsquo;s going on here.  This is the typical look of a Flask app, after
all. The additional things we have to do are, in order:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Attach the suite to the Flask app as &lt;code&gt;app.suite&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;init&lt;/code&gt; the app. This sets up CORS if it&amp;rsquo;s been configured and makes sure that logging is handled correctly.&lt;/li&gt;
&lt;li&gt;Ensure the application objects exist in the database.&lt;/li&gt;
&lt;li&gt;Register the &lt;code&gt;api_tree&lt;/code&gt; blueprint with Flask, typically at &lt;code&gt;/api&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>An Intro to Sondra: Part 1</title>
      <link>https://jeffersonheard.github.io/2016/11/an-intro-to-sondra-part-1/</link>
      <pubDate>Sun, 13 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>https://jeffersonheard.github.io/2016/11/an-intro-to-sondra-part-1/</guid>
      <description>

&lt;p&gt;This tutorial serves as a basic introduction to Sondra, its data model, and how you
can create an API. The classic example web API is that of a to-do list application. Our tutorial
will build it up in stages, starting with the basic structure of an application, followed by data
modeling, and then we&amp;rsquo;ll add exposed methods to see how those work.&lt;/p&gt;

&lt;p&gt;Finally, you&amp;rsquo;ll work through accessing the API via Javascript (ES2015) and Python.&lt;/p&gt;

&lt;p&gt;To do this tutorial, you will need the following installed and ready to go:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Sondra - &lt;a href=&#34;https://github.com/JeffHeard/sondra.git&#34;&gt;https://github.com/JeffHeard/sondra.git&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;RethinkDB - &lt;a href=&#34;https://rethinkdb.com&#34;&gt;https://rethinkdb.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Python 3 - &lt;a href=&#34;https://www.python.org&#34;&gt;https://www.python.org&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Your favorite text editor or IDE. I like &lt;a href=&#34;https://www.atom.io/&#34;&gt;Atom&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;first-steps&#34;&gt;First Steps&lt;/h3&gt;

&lt;p&gt;First thing&amp;rsquo;s first. Let&amp;rsquo;s make sure Sondra has all its requirements.  Assuming you have a virtual
environment setup already, all you have to do is install requirements.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ cd sondra
$ pip install -r requirements.txt
$ export PYTHONPATH=$PYTHONPATH:$PWD  # if you want to develop in a different directory or run the examples.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s start with some imports.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from sondra.collection import Collection
from sondra.document import Document
from sondra.application import Application
from sondra.suite import Suite
from sondra.schema import S
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These imports serve to introduce us to the basic building blocks of Sondra: Application, Collection,
and Document. We will subclass each to create our application.  The &lt;strong&gt;Document&lt;/strong&gt; subclass defines
the schema of a record in &lt;a href=&#34;https://rethinkdb.com/&#34;&gt;RethinkDB&lt;/a&gt; and all the methods that operate
directly on a record instance.&lt;/p&gt;

&lt;p&gt;The &lt;strong&gt;Collection&lt;/strong&gt; subclass defines the way a document relates to the database. It defines things
such as primary key and indexes and methods that operate on the collection as a whole. Methods
defined on the collection class are conceptually similar to class methods in Python.&lt;/p&gt;

&lt;p&gt;The &lt;strong&gt;Application&lt;/strong&gt; subclass defines a group of collections that serve a common purpose.  The
application will often contain schema fragment definitions that are common across multiple related
collections and methods that apply to multiple collections across the application.&lt;/p&gt;

&lt;p&gt;The &lt;strong&gt;Suite&lt;/strong&gt; subclass defines the complete API suite, including configurations and database
connections. Applications are added to the Suite.&lt;/p&gt;

&lt;p&gt;Finally &lt;strong&gt;S&lt;/strong&gt; is a utility module whose functions return dictionaries that fit the format of
&lt;a href=&#34;http://json-schema.org/&#34;&gt;JSON Schema&lt;/a&gt; and hyper-schema.&lt;/p&gt;

&lt;h3 id=&#34;modeling-data&#34;&gt;Modeling Data&lt;/h3&gt;

&lt;p&gt;So let&amp;rsquo;s start by creating a Document that models a to-do list item:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from sondra.collection import Collection
from sondra.document import Document
from sondra.application import Application
from sondra.suite import Suite
from sondra.schema import S

class Item(Document):
    schema = {
      &amp;quot;type&amp;quot;: &amp;quot;object&amp;quot;,
      &amp;quot;required&amp;quot;: [&amp;quot;title&amp;quot;],
      &amp;quot;properties&amp;quot;: {
        &amp;quot;title&amp;quot;: {&amp;quot;type&amp;quot;: &amp;quot;string&amp;quot;, &amp;quot;description&amp;quot;: &amp;quot;The title of the item&amp;quot;},
        &amp;quot;complete&amp;quot; {&amp;quot;type&amp;quot;: &amp;quot;boolean&amp;quot;, &amp;quot;default&amp;quot;: False},
        &amp;quot;created&amp;quot;: {&amp;quot;type&amp;quot;: &amp;quot;string&amp;quot;, &amp;quot;format&amp;quot;: &amp;quot;date-time&amp;quot;}
      }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we&amp;rsquo;ve defined a simple item that has a title, a space to mark whether the to-do item is
complete, and a creation date.  Note that schemas are just Python dicts. As long as your dictionary
and all its elements are compatible with the built-in &lt;code&gt;json&lt;/code&gt; package, your schema will work.
However, this syntax is rather verbose and prone to typo-induced bugs. Therefore the &lt;code&gt;S&lt;/code&gt; package
provides a bunch of utility functions that generate schema objects. These functions return plain old
dicts, so there&amp;rsquo;s functionally no difference between the two syntaxes, but the S module is safer:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Item(Document):
    schema = S.object(
        required=[&#39;Title&#39;],
        properties=S.props(
            (&amp;quot;title&amp;quot;, S.string(description=&amp;quot;The title of the item&amp;quot;)),
            (&amp;quot;complete&amp;quot;, S.boolean(default=False)),
            (&amp;quot;created&amp;quot;, S.datetime()),
    ))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s much shorter! Again, there&amp;rsquo;s no magic to the &lt;code&gt;S.*&lt;/code&gt; functions. They&amp;rsquo;re just shorthand and
provide a bit more checking.  It&amp;rsquo;s the same schema as above.  One difference is that the first
example does not enforce any order (except in Python 3.6!) on the dictionary elements.  The version
in the most recent example does, because &lt;code&gt;S.props&lt;/code&gt; uses an &lt;code&gt;OrderedDict&lt;/code&gt; instead of a plain &lt;code&gt;dict&lt;/code&gt;
Now let&amp;rsquo;s see how to get it into a collection and an application, and thus into the database. The
next three classes define the collection (RethinkDB table), application (RethinkDB database), and
the suite (the full group of applications, served on a single tree from a single domain):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Items(Collection):
    document_class = Item  # this is the class that as instances per-record
    indexes = [&amp;quot;title&amp;quot;, &amp;quot;complete&amp;quot;]  # the fields to build indexes on.
    order_by = [&amp;quot;created&amp;quot;]  # Sondra treats &amp;quot;format&amp;quot;: &amp;quot;date-time&amp;quot; as a RethinkDB Date.

class TodoApp(Application):
    collections = (Items,)  # For now we&#39;ll just define the collections

class TodoSuite(Suite):
    cross_origin = True  # append CORS headers
    debug = True  # extra logging
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;getting-it-into-rethinkdb&#34;&gt;Getting it into RethinkDB&lt;/h3&gt;

&lt;p&gt;Now that we have all the definitions set up, let&amp;rsquo;s get our data into the database:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; todo = TodoSuite()
&amp;gt;&amp;gt;&amp;gt; TodoApp(todo)
&amp;gt;&amp;gt;&amp;gt; todo.validate()
&amp;gt;&amp;gt;&amp;gt; todo.ensure_database_objects()

INFO:TodoSuite:Connection established to &#39;default&#39;
INFO:TodoSuite:Suite base url is: &#39;http://localhost:5000/api&#39;
INFO:TodoSuite:Docstring processor is {0}
INFO:TodoApp:Registering application todo-app
INFO:TodoSuite:Registered application TodoApp to http://localhost:5000/api/todo-app
INFO:TodoApp:Creating collection for todo-app/items
INFO:TodoSuite:Checking schemas for validity
INFO:TodoSuite:+ todo-app
INFO:TodoSuite:--- items
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The call to &lt;code&gt;todo.ensure_database_objects()&lt;/code&gt; creates / ensures the existence of tables and indexes and even
databases for everything that&amp;rsquo;s a part of the suite.  It should always be called once when your
application initializes. At the most basic level, you&amp;rsquo;re now ready to expose your API to your
clients now (we&amp;rsquo;ll handle authentication later), and you can play around with it in Python as well.
In Python, Sondra tries to be as pythonic as possible. All levels of the API are exposed as
dictionary-like objects. The keys are dash-cased versions of the classnames (this can be overridden,
  but is the default).&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Sondra: Schema validated API and ORM for RethinkDB</title>
      <link>https://jeffersonheard.github.io/2016/10/sondra-schema-validated-api-and-orm-for-rethinkdb/</link>
      <pubDate>Mon, 03 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>https://jeffersonheard.github.io/2016/10/sondra-schema-validated-api-and-orm-for-rethinkdb/</guid>
      <description>

&lt;div class=&#34;alert info &#34;&gt;
  &lt;p&gt;

Note I have just gotten the news that the company behind RethinkDB is shutting
down. They are committed and I am committed to RethinkDB continuing as a robust
Open Source project. In the next week, there will be a general polishing of the
Sondra documentation and a pruning / cleanup of Sondra. This will precede a
1.0.0 release of Sondra. In the future, we will concentrate on supporting
multiple databases, asynchronous communication (websockets!) and OAuth-based API
authentication.  I wish the RethinkDB folks the best of luck, and want to
reiterate my continued commitment to what I think is the best NoSQL database out
there.

&lt;/p&gt;
&lt;/div&gt;

&lt;h2 id=&#34;what-is-sondra&#34;&gt;What is Sondra?&lt;/h2&gt;

&lt;p&gt;Sondra is an &amp;ldquo;ORM&amp;rdquo; and REST-ful webservice framework for Python 3.x, Flask, and
RethinkDB with some unique features. Sondra&amp;rsquo;s goal is to aid full stack
developers by letting them focus on data models and functionality instead of
writing workarounds and glue code. It embraces common &amp;ldquo;shortcuts&amp;rdquo; developers
take in common full-stack web applications, e.g. merging &amp;ldquo;Model&amp;rdquo; and
&amp;ldquo;Controller&amp;rdquo; in the oft-used MVC pattern.&lt;/p&gt;

&lt;p&gt;Sondra does not currently support asynchronous access to RethinkDB.  The goal
is to eventually support &lt;code&gt;Tornado&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;features&#34;&gt;Features&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;A clear, DRY heirarchical application structure that emphasizes convention over configuration.&lt;/li&gt;
&lt;li&gt;Authentication via JSON Web Tokens (JWT)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.json-schema.org&#34;&gt;JSON-Schema&lt;/a&gt; validation for documents.&lt;/li&gt;
&lt;li&gt;Expose methods on documents, collections, and applications, complete with schemas for call and return.&lt;/li&gt;
&lt;li&gt;A clear, predictable URL scheme for all manner of API calls, covering a broad set of use-cases.&lt;/li&gt;
&lt;li&gt;Self documenting APIs with both human-readable help based on docstrings and schemas for every call.&lt;/li&gt;
&lt;li&gt;Use API idiomatically over HTTP and native Python without writing boilerplate code&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;concept&#34;&gt;Concept&lt;/h2&gt;

&lt;p&gt;A Sondra API is exposed in Flask as a suite of applications.  Each application
contains a number of document collections, and each collection contains a
number of documents.&lt;/p&gt;

&lt;p&gt;Sondra tries to take advantage of all manner of Python idioms in a sane manner.
It generates as much as possible, while avoiding &amp;ldquo;magic tricks&amp;rdquo; or introducing
conventions that are already covered by Python idioms. This means that:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Online documentation is generated at every level from reStructuredText or Google style docstrings.&lt;/li&gt;
&lt;li&gt;Method schemas are generated from annotated function signatures&lt;/li&gt;
&lt;li&gt;All URL features that &lt;code&gt;urllib.parse&lt;/code&gt; recognizes are taken advantage of to
create a regular URL scheme that encompasses all manner of calls.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;web-services&#34;&gt;Web Services&lt;/h3&gt;

&lt;p&gt;Sondra uses a regular URL scheme for its web services. See the docs directory for more details:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Underscores in Python identifiers are replaced with more web-friendly dashes (slugs)&lt;/li&gt;
&lt;li&gt;Paths address app / collection / instance (document)&lt;/li&gt;
&lt;li&gt;The last path element include an optional separator, (by deafult a dot or a colon) which separates the object being addressed and a method being
called.&lt;/li&gt;
&lt;li&gt;Fragments allow the caller to address sub-documents in JSON responses. Fragments delimted with &lt;code&gt;#&lt;/code&gt; are not passed by
browsers to the server. The alternative for delimiting fragments is &lt;code&gt;@!&lt;/code&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Path parameters (on the last element, with a &amp;ldquo;;&amp;rdquo;, see the URL spec or &lt;code&gt;urlparse&lt;/code&gt; docs) are used to specify output
format or content directives. Currently supported:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;json&lt;/code&gt; or &lt;code&gt;format=json&lt;/code&gt; retrieves data in JSON format.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;geojson&lt;/code&gt; or &lt;code&gt;format=geojson&lt;/code&gt; retrieves data in GeoJSON feature or feature collection format.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;help&lt;/code&gt; or &lt;code&gt;format=help&lt;/code&gt; retrieves HTML autogenerated help.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;schema&lt;/code&gt; or &lt;code&gt;format=schema&lt;/code&gt; retrieves a JSON-Schema document for the service call.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;documents&#34;&gt;Documents&lt;/h3&gt;

&lt;p&gt;A &lt;code&gt;Document&lt;/code&gt; is a single document that conforms to a JSON-Schema &lt;code&gt;object&lt;/code&gt; type.
That is, it is never a simple type nor an array of items.&lt;/p&gt;

&lt;p&gt;Documents may expose methods to the HTTP api.  These are similar to instance
methods in Python.  They operate on an individual document in a collection
instead. Document methods might include operations that combine multiple
documents to make a third (add, multiply, divide, subtract, or similar) or they
might provide specific views of a document.  Anything that you would write as
an &amp;ldquo;instance method&amp;rdquo; in Python.&lt;/p&gt;

&lt;h3 id=&#34;collections&#34;&gt;Collections&lt;/h3&gt;

&lt;p&gt;A &lt;code&gt;Collection&lt;/code&gt; is a RethinkDB table that contains a specific subclass of
&lt;code&gt;Document&lt;/code&gt;, which is defined by a single JSON-Schema. The collection class
defines additionally:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The primary key name (defaults to the RethinkDB default of &amp;ldquo;id&amp;rdquo;)&lt;/li&gt;
&lt;li&gt;Indexes&lt;/li&gt;
&lt;li&gt;Any document properties that require &amp;ldquo;special treatment&amp;rdquo; in RethinkDB such as geographical and date/time types.&lt;/li&gt;
&lt;li&gt;Relations to other Collections&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;Application&lt;/code&gt; class it belongs to.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Collections may expose methods to the HTTP api.  These are similar to class
methods in Python, as they operate on the collection itself and not the
individual documents. Collection methods might provide special filtering,
create documents according to a specific template, or set properties on the
collection itself. Anything you would write as a &amp;ldquo;class method&amp;rdquo; in Python&lt;/p&gt;

&lt;h3 id=&#34;applications&#34;&gt;Applications&lt;/h3&gt;

&lt;p&gt;An &lt;code&gt;Application&lt;/code&gt; is a reusable grouping of collections and a set of optional
&lt;em&gt;application methods&lt;/em&gt;, which operate a bit like globally available functions.
Applications are bound to a single database within RethinkDB.&lt;/p&gt;

&lt;p&gt;Applications may expose methods to the HTTP api.  These are similar to the
functions that are defined at the module level in Python.  They are not
specific to a particular class or instance, but instead are defined to provide
broad functionality for the whole application.&lt;/p&gt;

&lt;h3 id=&#34;the-suite&#34;&gt;The Suite&lt;/h3&gt;

&lt;p&gt;A &lt;code&gt;Suite&lt;/code&gt; defines the environment of applications, including database
connections and provides some basic functionality. Every application is
registered with the global &lt;code&gt;Suite&lt;/code&gt; object, which itself implements Python&amp;rsquo;s
Mapping protocol to provide dictionary-like lookup of application objects.  The
&amp;ldquo;Suite&amp;rdquo; object determines the base path of all Application APIs. Suites are
similar in nature to Django&amp;rsquo;s &lt;code&gt;settings.py&lt;/code&gt; except that they are class-based.
There may be only &lt;em&gt;one&lt;/em&gt; concrete class of Suite in your Flask app, although it
may derive from any number of abstract Suite mixins.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>